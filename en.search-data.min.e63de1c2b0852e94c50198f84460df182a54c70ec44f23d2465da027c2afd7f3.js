"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/angular/",title:"Angular",section:"Introduction",content:` Angular, the fancy web framework # Angular lets you make dynamic web apps easily. This was written when Angular 14 came out.
Base Knowledge # I know nothing about Angular. I know a bare minimum of HTML, CSS, and JS. 😰 let\u0026rsquo;s see how this goes. YOLO 🙂.
Course stuff # I\u0026rsquo;m following along The Angular Fundamentals course on Pluralsight. The authors have nice practice exercises available on their website. Code for the course is available on GitHub.
This Crash Course by Traversy Media is also very good.
Finally, The Angular docs are very good.
Just to note, the content I put up here is whatever I understood out of the courses and many other sources off the internet. I haven\u0026rsquo;t and I won\u0026rsquo;t, purposefully, rip content off sources I haven\u0026rsquo;t listed here. I try to write this stuff on my own but sometimes, when it comes to things like specs and such, they do need to be put in word for word.
Fun stuff # Some cool things I learnt along the way:
When you run ng new coolstuff, it generates a lot of files. The file structure is explained here. The JSON pipe is useful when you want to display an object in a template. Use it like this: {{ objkt | json }} To see what happens when you run an ng command, suffix it with --dry-run There\u0026rsquo;s the options to convert your components into web components. This means they can be framework agnostic. They\u0026rsquo;re still working on making the output Angular free at the time of writing this post. Web components have good browser support. `}),e.add({id:1,href:"/front-end-stuff/",title:"Front-End",section:"Introduction",content:` Front-End stuff # Don\u0026rsquo;t really have any plans for what this section should contain. Here, have some fun facts while I figure out what should be on this page.
Fun facts # Variable hoisting was an unintended addition that came along with function hoisting when JS was being developed. Hoisting is done by the two-scan interpreter. The first scan is to find declarations. This stackoverflow q\u0026amp;a has some good answers. There\u0026rsquo;s no concept of \u0026ldquo;initialization\u0026rdquo; in JS. There is declaration (let a) and there is assignment (a = 2). \u0026ldquo;Definition\u0026rdquo; is just syntax sugar to do both declaration and assignment at once. typeof null evaluates to 'object' in JS. Which is a bug apparently. While writing the CSS for a site, it\u0026rsquo;s a good idea to write it mobile first and then add media queries for the larger screen sizes. It leads to less CSS. Even if the design was desktop based. JS has so many inbuilt things. Proxy is one of them. Want to know if you\u0026rsquo;ve covered all best-practices and stuff for your web app? There\u0026rsquo;s a nice checklist A book about building web apps by Basecamp. It\u0026rsquo;s good apparently. PDF also available. `}),e.add({id:2,href:"/angular/overview/",title:"Overview",section:"Angular",content:` An overview (and miscellaneous stuff) # Angular is a platform, apparently, that includes a framework, some libraries, and developer tools to work with all of that. For most purposes, it\u0026rsquo;s called a front-end web development framework.
Typescript # Angular uses TS. It\u0026rsquo;s a superset of JS that compiles to JS. You can adding typing via syntactic sugar which helps catch bugs when you compile. It also has editor plugins for the same. You can try it out online. Its main features are:
Static typing # You can declare types while declaring variables, like so: let var: number;.
Interfaces # They let you define a structure that objects must follow. An interface is a type. When you assign an object to a variable of that type, the object must have the properties in that interface (each of the same type). Like so
interface nice { name: string, age: number } let sic: nice; sic = { name: \u0026#34;hai\u0026#34;, // adding, removing, or changing the types of these properties causes an error age: 10 }; Class properties # ES6 classes mainly define their properties via their constructors. TS lets you to define these properties in the class itself. You can optionally specify types for them. This is only for readability. E.g.
class Hip { num: number wutdis constructor() { this.num = 10; this.wutdis = \u0026#34;hmm\u0026#34;; } } Public / Private access # All class properties in ES6 are public. You can make them private in TS by adding the private before them during declaration. It also provides this nifty shorthand for the constructor:
class Hip { constructor(public wutdis: string, private num) { // it implicitly does this.wutdis = wutdis } } let f = new Hip(\u0026#34;sic\u0026#34;, 10); console.log(f); // { wutdis: \u0026#34;sic\u0026#34;, num: 10 } The bootstrap process # The first file that is run is main.ts (as defined in angular.json That\u0026rsquo;s a very useful file). It bootstraps a module, app/module.ts by default. It bootstraps the root component, app/app.component.ts by default. The root component is placed in app/index.html which is what is rendered. Modules and libraries # Only the root NgModule should have a bootstrap property in its decorator. The bootstrap property sets the root component for the app. Libraries are plain JS modules which can have angular modules. A component / directive / pipe can be declared in only one NgModule To use stuff that other module provide, you import that NgModule in this NgModule When you list services in the providers array, they are available app wide. It\u0026rsquo;s possible to have multiple entry point components in the bootstrap array. File structure of workspace # Deployment 🎈 # This is done with the ng build command which:
Minifies code (removes whitespaces and renames variables) Bundling (merges many JS file into a single JS file) so fewer requests are made Tree shaking (the production app doesn\u0026rsquo;t have code that is never used). It\u0026rsquo;s a little different from dead code elimination. Angular has an Ahead Of Time (AOT) compiler that converts the HTML of templates into JS code that manupilates the DOM. It can help catch template errors, reduce the output size, and make rendering on the browser faster.
By default, running ng build will generate a \u0026ldquo;development\u0026rdquo; build which can still be deployed but isn\u0026rsquo;t as optimized as it could be. To run it in \u0026ldquo;production\u0026rdquo; mode use ng build --prod which reduces the number of requests and file sizes.
Deployment just involves copying the directory within \u0026ldquo;dist\u0026rdquo; to the web server!
`}),e.add({id:3,href:"/angular/components/",title:"Components",section:"Angular",content:` The real CONTENT # Fun fact: The @Component decorator actually extends @Directive decorator because components are technically directives.
Creating them # A bare component is a class, defined in a .ts file. You can create new one like this:
Create a .ts file and export a class that is decorated by Component from @angular/core. The decorator takes in an object as argument. The object has properties like selector (which is a CSS selector to find out which HTML elements this component should apply to) and template (or templateUrl). Import this class in app.module.ts and add it to declarations in the NgModule decorator of AppModule. Data binding: Accessing the component\u0026rsquo;s properties within its template via the {{ any JS expression }} syntax.
The constructor of a component should ideally be empty, put intialization code in ngOnInit.
Communicating with a child component # When you have a child component within your component you can pass data to it via HTML attributes. The process is:
Create a property on the child component class that is prefixed by the @Input() decorator. E.g. @Input() title: string In the child component\u0026rsquo;s tag in the parent component\u0026rsquo;s template, pass the value like this: \u0026lt;child-comp [title]=\u0026quot;any JS expression\u0026quot;\u0026gt;\u0026lt;/child-comp\u0026gt; You can react to changes in any of the input properties via ngOnChanges(){} You can also set an input propert setter like so: @Input() set propname(val) {} where the function is called every time propname changes. Just like a JS setter. Communicating with the parent component # The common patern here is passing along an event to the parent component. It works like this, overall:
Create an event handler to respond to some event in the child HTML. Just a function property of the class. Like so, handleHere() {} Create an event emitter property that is decorated by Output. Like so, @Output() handledByParent = new EventEmitter() In the even handler you can call handledByParent.emit(anyVal) which will emit an event by the child component In the parent, you can create a handler for the event, like so: \u0026lt;child-comp (handledByParent)=\u0026quot;parentHandler(\$event)\u0026gt;\u0026lt;/child-comp\u0026gt;. \$event is a special keyword that contains the value passed to emit. You can only pass one value. parentHandler is a function property of the parent component. Styling em # You can add styles for a component (other than the global styles), in two ways:
Create an array of strings, where each one can have CSS style rules and assign that to the styles property of the decorator object of the component Add the rules in a file and create an array of strings (with file names) and assing it to styleUrls. Within the styles, if you want to refer to the element which the component is tied to (i.e., the one in the component\u0026rsquo;s selector) use :host, e.g., :host { font-style: monospace; } CSS Encapsulation # When you add CSS styles to your component, it only matches the elements directly in the component. It does not apply to a parent or child component. This is how that works:
Angular automatically adds attributes to every element within a component. Within a component, they all have the same attribute which is unique to elements in that component. It also modifies the CSS of that component to apply only when that attribute is present.
There is a way to pass down styles to children by using a \u0026ldquo;deep\u0026rdquo; selector (google when needed).
Global styles are not mangled like this.
Content Projection # AKA \u0026ldquo;How to reuse components\u0026rdquo;. Components have \u0026ldquo;content slots\u0026rdquo; within them. You can reuse a component by putting different content within these slots.
If the parent template looks like:
\u0026lt;h2\u0026gt;Hip hop\u0026lt;/h2\u0026gt; \u0026lt;somechildcomp\u0026gt; \u0026lt;button\u0026gt;woop\u0026lt;/button\u0026gt; \u0026lt;h3\u0026gt;sneak\u0026lt;/h3\u0026gt; \u0026lt;/somechildcomp\u0026gt; The button and the h3 (basically all content within those tags) will be available to the child component via \u0026lt;ng-content\u0026gt;\u0026lt;/ng-content\u0026gt;
Multiple content slots can be used with multiple ng-contents. This is how you would do it: In the parent template:
\u0026lt;div someattr1\u0026gt; \u0026lt;!-- stuff for first content slot --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;whodisboi\u0026#34;\u0026gt; \u0026lt;!-- stuff for second content slot --\u0026gt; \u0026lt;/div\u0026gt; The HTML content within those slots can be used like so:
\u0026lt;header\u0026gt; \u0026lt;ng-content select=\u0026#34;[someattr1]\u0026#34;\u0026gt;\u0026lt;/ng-content\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section\u0026gt; \u0026lt;ng-content select=\u0026#34;#whodisboi\u0026#34;\u0026gt;\u0026lt;/ng-content\u0026gt; \u0026lt;/section\u0026gt; The select attribute of ng-content takes in CSS selectors to match the HTML content from the parent.
The ng-container tag itself will not be present in the DOM. Accessing DOM with viewChild # To access the DOM of the HTML of a component:
Give it a temp-ref-var like so: \u0026lt;div #theBestElem\u0026gt;\u0026lt;/div\u0026gt; Create a property on the component decoreated by viewchild like so: viewChild('theBestElem') goodie: ElementRef The selector could also be a component / directive / service class You can then access its DOM properties or get even more granular control with nativeElement. Lifecycle # A component goes through a set of events during its lifecycle. It\u0026rsquo;s possible to \u0026ldquo;hook\u0026rdquo; to those events (i.e., perform some extra actions you want). Some of these hooks are:
ngOnInit ngOnChanges ngAfterContentInit ngAfterViewInit A full list of them, when they\u0026rsquo;re called and what they do is present in the docs
Dynamic loading! # TODO: get back to this. The docs was a bit more complicated than expected.
`}),e.add({id:4,href:"/front-end-stuff/d3/",title:"D3",section:"Front-End",content:` Data Driven Docs? # It\u0026rsquo;s a powerful library with a bit of a learning curve.
There a heck lot of things it can do. Nice confusion. These might be some good resources:
An updated D3 tutorial (This was the best!) Official tutorial (It can take some time to get used to observableHQ\u0026rsquo;s notebooks) Huge collection of tutorials [SUGGESTION]: Do the d3indepth tutorial first and practise a bit by trying to make your own visualizations. The other resources can be useful when you\u0026rsquo;re stuck.
SVGs # This is one popular way to display graphics onto a webpage. It\u0026rsquo;s the one that most D3 visualizations use.
There are already good resources available online. Check them out:
Kevin Powell\u0026rsquo;s guides on YouTube Understanding SVG by Sara Soueidan - this is a series of 3 articles, at the end of this one there\u0026rsquo;s a link to the next one. They\u0026rsquo;re pretty deep and help you understand what\u0026rsquo;s really going on. Selection # One feature of d3 is the ability to select and modify the DOM.
Core to this are select and selectAll which take in an HTML Element or a CSS selector. Both return a Selection object.
API for selecting and selections.
Properties # The object has a few functions, each of which return a Selection object (that means chaining is possible)
Function Params Description style \u0026lsquo;css-prop\u0026rsquo;, value Sets a css property attr \u0026lsquo;html-attr\u0026rsquo;, value Sets an attribute on the HTML element classed \u0026lsquo;classname\u0026rsquo;, value Removes or adds class depending on value property \u0026lsquo;html-prop\u0026rsquo;, value Sets HTML attributes which can\u0026rsquo;t be set by \u0026lsquo;attr\u0026rsquo;. E.g. checked on a checkbox text value Sets the text within a HTML element html value Sets HTML within the selected element select CSS selector Can be used to select child elements value can be an actual value or a function. The function takes in two params:
d the datum, which is the data value corresponding to the index i the index of the element among other elements in the Selection. Its possible to add an event to the Selection with the on property like so:
d3.select(\u0026#39;rect\u0026#39;) .on(\u0026#39;hover\u0026#39;, function(event, datum) { // can be any DOM event // \`this\` inside this function refers to the HTMLElement // to get a d3 Selction from it you must do d3.select(this) }); Because of the way this works inside arrow functions, don\u0026rsquo;t use arrow functions for the callback of on if you want to use this.
When it comes to D3, it might just be a good idea to use function for most use cases.
Insertion / Deletion # Its possible to insert / remove DOM elements with D3. The functions are:
.append('element-tag') creates the specified element as the last child of the selection .insert('element-tag', 'css-selector') same as append but it places this element before the CSS selector specified .remove removes the element(s) in the Selection from the DOM Processing # A Selection can be processed in these ways:
.each(function(d, i){} calls the function for each element. .call(function(theSelection){}) calls the function once for the selection. It passes the selection object as an argument. .filter(function(d, i){}) calls the function for each element. It returns a new selection that only contains elements that returned true in the filter function. .sort(function(datumA, datumB){}) sorts the elements in the DOM with the comparator function. Data Joins # Modifying visual elements according to data in a declarative manner. It usually works like this:
Create a Selection of the parent element which will hold the visual elements. Create an empty Selection with .selectAll('element-to-join'). Create a Selection with data by calling the data method on it with an array as the argument. On the latest selection call .join('element-to-insert') Article to help with understanding joins. Another article. This one\u0026rsquo;s about modern joins
Selection Join # This join automatically appends and removes elements but also provides the ability for fine control. A sample:
d3.select(\u0026#39;g\u0026#39;) .selectAll(\u0026#39;circle\u0026#39;) .data(array) .join(\u0026#39;circle\u0026#39;) .attr(\u0026#39;fill\u0026#39;, \u0026#39;blue\u0026#39;); To control what happens to enter, update and exit elements, pass functions as args to it like so:
selexon.join( function(enterSelection){}, function(updateSelection){}, function(exitSelection){} ) Keys # It\u0026rsquo;s possible to make sure that DOM elements are exactly matched with the same data even if the elements are moved around. This is possible via a key function which assigns keys to DOM elements based on the data they get like so:
xyz.data(array, function(d){ /* return unique id */ }) Enter, Exit \u0026amp; Update # This picture from https://bost.ocks.org/mike/join/ is a good explanation: This way of joining is fine-grained but it can be tedious. It\u0026rsquo;s mainly used for transitions. A more concise way is using the new selection join (D3 v5+).
An example. Given a DOM like:
\u0026lt;svg\u0026gt; \u0026lt;g\u0026gt; \u0026lt;circle\u0026gt;\u0026lt;/circle\u0026gt; \u0026lt;circle\u0026gt;\u0026lt;/circle\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt; Circles can be selected like so:
let data = [10, 8, 15]; let circs = d3.select(\u0026#39;g\u0026#39;).selectAll(\u0026#39;circle\u0026#39;); Existing elements can be joined with data like so:
circs.data(data).attr(\u0026#39;r\u0026#39;, d =\u0026gt; 2*d); New elements can be created for extra datum:
circs.data(data).enter().append(\u0026#39;circle\u0026#39;) Elements which don\u0026rsquo;t have a datum:
circs.data(data).exit() Scales # Scales provide a way to map values from a domain to a range. They can be continuous or discrete. (There\u0026rsquo;s no scale for D to C though).
Usually the domain consits of data values and the range consists of visual properties (height, position, color, etc.)
C to C # There are many scales here: Linear, Quadratic, Log, Exponential, etc. An example:
let scale = d3.scaleLog(); scale.domain([1, 100]); scale.range([0, 1]); let scaledVal = scale(50); For fancy colors there\u0026rsquo;s also d3.scaleSequential() which instead of a range, has an interpolator. E.g. scale.interpolate(d3.interpolateRainbow)
C to D # A straightforward function is .scaleQuantize() which splits the domain into equal divisons among the range. It also clamps inputs into the domain.
To split the domain into specific groups .scaleThreshold() can be used. .domain([/* array of n values */]) will create n+1 groups (\u0026lt;arr[0], \u0026gt;arr[0] \u0026amp; arr[1]\u0026lt;, \u0026hellip; arr[n-1]\u0026lt;). They are matched one-one with the range items. If there aren\u0026rsquo;t enough elements in the range, the groups are allocated to the last item.
D to D # The simplest way to do this is .scaleOrdinal() where the elements in domain are allocated on range element. If there aren\u0026rsquo;t enough range elements the array repeats. If the value to be scaled doesn\u0026rsquo;t exist in the domain, the scale will automatically add it. To prevent it from being added, specify a default value to be returned for unknown elements with scale.unknown(value)
There are other functions too like .scaleBand() and .scalePoint().
Shapes \u0026amp; Lines # D3 has generator functions to generate paths that represent line graphs, pie charts, curves, and more. This works using the \u0026lt;path\u0026gt; SVG tag and setting its d (data) attribute to a special strings returned by the functions which contain instructions on how to draw the required shapes.
Common generators # Name Description Configurable params line Simple line graph x, y for each point in the line radialLine Like a line graph but instead of going left to right, it goes around a center angle, radius for each point around the center area Area between two lines (need not be straight lines) x, y0 for top line, and y1 for bottom radialArea Like how radialLine is to line angle, innerRadius, and outerRadius The configurable params can either be a function that takes in one value and returns a value, or it can be a value. E.g. lineGenerator.x(909) and lineGenerator.x(d =\u0026gt; d+10) both work.
Example usage:
let inputData = [/* complex objects */] let lineGen = d3.line(); lineGen.x(arrayVal =\u0026gt; arrayVal.prop1 + 10) lineGen.y(arrayVal =\u0026gt; arrayVal.prop2 - 5) let pathData = lineGen(inputData); d3.select(\u0026#39;path\u0026#39;).attr(\u0026#39;d\u0026#39;, pathData) Instead of passing an array of objects and configuring each param, the user can also just feed an array of arrays to the generator.
To handle invalid data in the array, the user can set .defined(datum =\u0026gt; {}) on the generator. D3 will skip the element if the callback function returns false for it.
Interpolation of the points can be changed by calling .curve(someCoolCurveGen) on the generator. Check out some popular curves in the docs.
Axes # These help give the user a scale of the data. An axis can be created in a container like \u0026lt;g\u0026gt;. Select the container. Create an axis with .axis[Left|Right|Top|Bottom](scale).
The scale\u0026rsquo;s domain determines the ticks on the graph and the range helps determine its length. The axis can then be passed to the container Selection like so: gSel.call(axis). That\u0026rsquo;s it!
It isn\u0026rsquo;t limited to uniform ticks. Different scales like .scaleSqrt() can be used with axes. To make the axis look better, the domain can be rounded to \u0026ldquo;nice\u0026rdquo; values like so: d3.scaleLinear().domain([11, 39]).nice() will change to domain to (10, 40).
The number of ticks can be changed by axis.ticks(n) or even set tick values like axis.tickValues([a, b, c, d]). The label of each tick can be formatted with something like .tickFormat(d =\u0026gt; \u0026quot;-\u0026quot;+d)
Hierarchies # There are multiple layouts here such as tree, cluster (just like a tree but all the leaves are on the same horizontal level), treemap, and so on. This section will focus on the tree layout.
It uses the output of d3.hierarchy, a nested object, to layout the tree. hierarchy itself needs a nested object as input or a map of maps.
hierarchy # Given an input with the format discussed above, hierarchy returns a nested object where each object (node) has the following params:
data : The item in the input data that this node is associated with. E.g. a map key and its value. children : array of references to children (not present in leaf nodes) depth height parent : reference to parent node It also has methods like:
descendants : Returns an array of all its descendants ancestors : Returns an array of all its ancestors links : Returns an array of all links under this subtree. A link looks like { source: reference to source node object, target: reference to target node object } Tree Layout # A tree layout function can be created like so: let funk = d3.tree(). The size this element will take in the DOM can be set like so: funk.size([ht, wd]). The layout can then be applied to the hierarchy object like so: funk(hierarchyOutput).
The tree\u0026rsquo;s size need not be set explicitly, instead, a combination of .nodeSize([ht, wd]) which sets the minimum space a node must be alloted, and .separation((a, b) =\u0026gt; 1) which sets the the space between two nodes in terms of nodeSize (e.g. 3 means a and b will be separated by the space that 3 nodes would occupy)
Applying a layout means it will add extra properties (display properties e.g. x and y locations) to each node in the hierarchy.
Now that the object has display properties, it can be used to create DOM nodes and position them.
Nodes # Use the rootNode.descendants() array along with a join for whatever shape you like (e.g. \u0026ldquo;circle\u0026rdquo;).
Edges # Use the rootNode.links() array along with a join which creates lines with \u0026ldquo;path\u0026rdquo;.
Transitions # When data gets updated, elements might have new places, might look different, or even vanish. Without smooth transitions, the transitions looks janky and not \u0026ldquo;natural\u0026rdquo;.
To have a transition just call transition() on the Selection before calling any attr methods for which you want a transition.
Could be position (e.g. \u0026lsquo;x\u0026rsquo;, \u0026lsquo;cx\u0026rsquo;), color (e.g. \u0026lsquo;fill\u0026rsquo;), or even size (e.g. \u0026lsquo;r\u0026rsquo;). It creates a transition Selection which has a few more methods and it automatically creates a transition when the join runs.
A delay can be added by calling delay(durationInMilli). A duration for the transition can be set with duration(durationInMilli)
Instead of setting a constant duration both the functions can take a callback function which can set determine the value according to some factor e.g. (d, i) =\u0026gt; i*1000
Calling transition() a second time in the Selection chain will cause the second one to play out after the first one has finished.
To put separate transitions for enter, exit, and update elements, use separate functions for the join and apply transition() within them where required. E.g.
coolSelection.join( function(enterSelect) { enterSelect.transition() .attr(\u0026#39;r\u0026#39;, d =\u0026gt; d+10) }, function(updateSelect) { updateSelect.transition() .attr(\u0026#39;fill\u0026#39;, \u0026#39;green\u0026#39;) }, function(exitSelect) { exitSelect.transition() .remove() } ) There are other topics too but this should be enough to get started.
`}),e.add({id:5,href:"/stolenstuff/",title:"/tmp",section:"Introduction",content:` Temporary code access # Random stuff that doesn\u0026rsquo;t fit anywhere else.
`}),e.add({id:6,href:"/angular/template/",title:"Template Syntax",section:"Angular",content:` The template syntax # The template builds the HTML content that is displayed for a component. It is HTML with some Angular template syntax which lets you make the component reusable.
There are HTML attributes and there are DOM properties. Sometimes there\u0026rsquo;s a one-one mapping between them, sometimes an attribute exists but has no corresponding property and vice-versa.
Binding in HTML JS in HTML? # There are multiple ways you can use JS objects in HTML. Two of them are:
Interpolation # In places within the HTML where you can put custom values (within tags, properties of attributes, etc) you can use the result of a JS expression like this: \u0026lt;div\u0026gt;{{ some JS expression }}\u0026lt;/div\u0026gt;. All the public properties of the component class are available. The result is always a string. This is because the toString() method is called on the result of the expression. The binding between the class properties and the text is one way. Updates to the property will be reflected in the HTML but not the other way around.
The variables referenced within the expression could come from multiple places, the order of search is:
The template variable name. A name in the directive\u0026rsquo;s context. The component\u0026rsquo;s member names. Interpolation is secure since Angular will process the text to make sure any HTML / JS the user might have provided is not executed, only displayed on the screen.
Prevent interpolation from executing the expression using ngNonBindable like so: \u0026lt;a ngNonBindable\u0026gt;{{ \u0026quot;will\u0026quot; + \u0026quot; not execute\u0026quot; }}\u0026lt;/a\u0026gt;
Property binding # HTML elements have properties e.g. \u0026ldquo;class, style, action, id, nonce, etc\u0026rdquo;. You can set the values of these properties, like so: \u0026lt;div [nonce]=\u0026quot; some JS expression \u0026quot;\u0026gt;\u0026lt;/div\u0026gt;. The result is not converted to a string.
If you don\u0026rsquo;t have the square brackets, the expression is not evaluated, it\u0026rsquo;s treated as a string. i.e., \u0026lt;a val=\u0026quot;12+45\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; will set the property val as '12+45' while \u0026lt;a [val]=\u0026quot;12+45\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; will set it as 57.
Angular sanitizes values passed to a property to prevent XSS.
Rules for expressions # You can\u0026rsquo;t use a few things, like these:
Assignment operators The new keyword to create objects ; to use multiple expressions Global namespace objects like console, window, etc. In general, here are a few guidelines you should follow:
The expression shouldn\u0026rsquo;t have side effects Try to keep them simple and fast Event binding # HTML elements also have events that they can emit e.g. \u0026ldquo;click, focus, hover, etc\u0026rdquo;. You can bind these events (which means running code when it emitted) to statements, like so: \u0026lt;div (hover)=\u0026quot; some JS statement \u0026quot;\u0026gt;\u0026lt;/div\u0026gt;.
Rules for statements # Statements can have assignments but only with =, not += or other stuff. They can have multiple expressions separated by ; but the other restrictions that held for expressions still hold. They mostly do have side effects.
Two way binding # This can be done like so : \u0026lt;child-elem [(lol)]=\u0026quot;someVal\u0026quot;\u0026gt;\u0026lt;/child-elem\u0026gt; which does a bunch of things:
The child element should have a property \u0026ldquo;lol\u0026rdquo; and an EventEmitter \u0026ldquo;lolChange\u0026rdquo; The parent should have a property \u0026ldquo;someVal\u0026rdquo; Whenever someVal is updated, lol will get the new value, just like normal property binding Whenever lolChange emits a value, someVal will be set to that value. *ngFor # ngFor is a structural directive. That means that it is capable of changing the DOM structure. It works like a for loop, where for each iteration it creates another instance of the element (and its children) on which it is called. It also provides a template reference variable for the element / its children to use. An example below:
\u0026lt;!-- x is the templ ref var and y is a property of the comp class --\u0026gt; \u0026lt;figure *ngFor=\u0026#34;let x of y\u0026#34;\u0026gt; \u0026lt;img [src]=\u0026#34;x.imzSrc\u0026#34;\u0026gt; \u0026lt;figcaption\u0026gt;{{x.imzCap10}}\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; undefined values # When you try to access an undefined value within a template, Angular will not display that element and it will throw an error in the console :(. If you are expecting something to be undefined you can use the JavaScript safe navigation operator ?. which returns undefined if its LHS is undefined else goes ahead. Check out the syntax on MDN.
*ngIf # ngIf lets you conditionally render the element it is put on. It decides this based on the expression provided to it, like so: \u0026lt;img *ngIf=\u0026quot;some JS expression\u0026quot;\u0026gt;. The component corresponding to the element (if ngIf is used on a component element and not a standard HTML Element) will be deleted too, thus freeing up memory.
It is important to note that in case the condition is falsy, the entire element is commented out. It\u0026rsquo;s not just hidden by some CSS / HTML property. In case some operations are done when the element is rendered and it is added / removed multiple times, it can slow down performance.
If you want to hide and un-hide the element multiple times you can do so with the HTML attribute \u0026ldquo;hidden\u0026rdquo; which you set like so: \u0026lt;img [hidden]=\u0026quot;some JS expression\u0026quot;\u0026gt;.
ngSwitch \u0026amp; co # This is to ngIf like a switch case is to an if condition. You define the switch condition like so: \u0026lt;div [ngSwitch]=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;. On the children you can use either:
\u0026lt;img *ngSwitchCase=\u0026quot;\u0026quot;\u0026gt; to compare particular JS objects (objects, not just strings) OR \u0026lt;img *ngSwitchDefault\u0026gt; which will come to life if none of the other cases matched Attribute binding # It\u0026rsquo;s recommended to use property binding wherever possible but sometimes the required element property does not exist. Some SVG attributes cannot be set via property binding because they have no \u0026ldquo;property targets\u0026rdquo;.
The simplest way to do this is: \u0026lt;elem [attr.whateverattributename]=\u0026quot;expr\u0026quot;\u0026gt;\u0026lt;/elem\u0026gt;. Note that the attr. prefix is necessary. If the expression evaluates to null or undefined the attribute is removed from the element.
Adding classes # There are multiple ways to do this. The simple way is for a single property like so: \u0026lt;img [class.klassname]=\u0026quot;bool JS expression\u0026quot;\u0026gt; which will add the class \u0026ldquo;klassname\u0026rdquo; to the element if the expression is truthy.
When you want to add multiple classes you can do so with ngClass like so \u0026lt;img [ngClass]=\u0026quot;fancy stuff\u0026quot;\u0026gt; where \u0026ldquo;fancy stuff\u0026rdquo; can be any JS expression that returns one of these:
An object, where the keys are class names and values are booleans which decide if that class will be added A string of space separated class names An array of strings, each of which are class names A function that returns any one of the above (just the function name, don\u0026rsquo;t call it!) Adding styles # The simple way to set a style would be using attribute binding like so: \u0026lt;elem [style.width]=\u0026quot;CSS.px(10)\u0026quot;\u0026gt;\u0026lt;/elem\u0026gt;. It\u0026rsquo;s also possible to set multiple styles like so: \u0026lt;a [style]=\u0026quot;{width: '100px', height: '2px'}\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;.
ngStyle can also be used to set styles. ngStyle has a similar syntax to ngClass except that the return value of the expression should be an object where the keys are CSS style keys and values are CSS style values. A small example: HTML element with \u0026lt;img [ngStyle]=\u0026quot;komPute\u0026quot;\u0026gt;. The function:
komPute() { if(/* condition */) return {\u0026#39;background-color\u0026#39;: \u0026#39;red\u0026#39;, display: \u0026#39;inline\u0026#39;}; return {display: \u0026#39;block\u0026#39;}; } Template reference variable # They help you use one part of a template in another. You can declare a variable on a tag, a component, or a bunch of other things as seen in the docs. For a tag, it is a reference to the TS object of that tag and for a component it a reference to an object of that child component class. If you define one in an ngIf or an ngFor you can\u0026rsquo;t access it outside those boundaries. This is how you use them:
Declare the variable like this \u0026lt;comp-or-tag #refVar\u0026gt;\u0026lt;/comp-or-tag\u0026gt; You can then use this in other parts of the template, if it\u0026rsquo;s a component you can access its public properties. Like so, \u0026lt;other-tag [lul]=\u0026quot;refVar.val1\u0026quot; (snap)=\u0026quot;refVar.func1()\u0026quot;\u0026gt; {{ refVar.val2 }} \u0026lt;/other-tag\u0026gt; It is not accessible in the TS of the parent component. How does this work with ngModel? According to the docs:
If the variable specifies a name on the right-hand side, such as #var=\u0026ldquo;ngModel\u0026rdquo;, the variable refers to the directive or component on the element with a matching exportAs name.
The same case with using the ngForm directive: \u0026lt;form #lol=\u0026quot;ngForm\u0026quot;\u0026gt;. lol will have values as specified by the ngForm directive.
Styling # Write styles in the sheets provided for the components. Angular performs \u0026ldquo;view encapsulation\u0026rdquo; which means a component\u0026rsquo;s styles are applied to only its elements. This happens by adding special attributes to the elements in the DOM e.g. \u0026lt;h2 somerandomNGattribute\u0026gt;\u0026lt;/h2\u0026gt; and adding that attribute to all encapuslated styles.
Styles provided in the global stylesheet are still applicable to all componenents. To remove this encapsulation you can either:
set encapsulation to ViewEncapsulation.None in the component\u0026rsquo;s metadata add ::ng-deep to child styles. This doesn\u0026rsquo;t remove the encapsulation but allows adding styles to elements that aren\u0026rsquo;t in the template. That\u0026rsquo;s not the only type of encapsulation, there\u0026rsquo;s also:
ViewEncapsulation.ShadowDom which gives this component a shadow DOM and places elements under that shadow root. All shadow elements styles are separated from global styles. Any style declared for components within this shadow DOM are attached to the shadow root. ViewEncapsulation.Emulated is the default and sets styles for only that component\u0026rsquo;s elements. The shadow DOM API is not available in all browsers (e.g. IE and Opera Mobile) but it\u0026rsquo;s available in most modern ones and is available to at least 94% of all users at the time of writing this. Check caniuse Thought only HTML files could be used as templates? SVGs can be used too! ng-template # TODO: A special section on ng-template, it seems to be pretty powerful.
`}),e.add({id:7,href:"/front-end-stuff/typescript/",title:"Typescript",section:"Front-End",content:` Write JavaScript with confidence # TODO: The docs are good. Check them out: https://www.typescriptlang.org/docs/.
Some notes # declare a in TS is used to tell the compiler that the variable a is declared somewhere else and it\u0026rsquo;s usage in this file should not throw an error. (e.g. it\u0026rsquo;s declared in another file and both of them are used via script tags in HTML)
Any definitions in a class declaration are moved to the constructor when the code is transpiled to JS. The code is also moved to the top of the constructor so that the constructor code can use the defined values. e.g. TS # class LOL { private a: number; private b: string; private c = \u0026#39;wow this is cool\u0026#39;; constructor() { this.a = 1; this.b = \u0026#39;wow\u0026#39; + this.c; } public z = \u0026#39;bongo cats\u0026#39;; } Compiled JS # class LOL { constructor() { this.c = \u0026#39;wow this is cool\u0026#39;; this.z = \u0026#39;bongo cats\u0026#39;; this.a = 1; this.b = \u0026#39;wow\u0026#39; + this.c; } } Testing # It can be somewhat painful.
1. Make a new tsconfig file # Aside from the tsconfig file that you\u0026rsquo;re already using for your source code. Something like this (in tsconfig.callitwhatyouwant.json)
{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, // required for tests \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;lib\u0026#34;: [ \u0026#34;es2015\u0026#34;, \u0026#34;es2016\u0026#34;, \u0026#34;es2017\u0026#34;, \u0026#34;dom\u0026#34; ], }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;, \u0026#34;./test/**/*.ts\u0026#34;] } remove stuff at your own risk. (But do try, this is somewhat of a mess)
2. Install stuff # I\u0026rsquo;m using Karma and Jasmine cuz they\u0026rsquo;re nice.
npm i -D karma karma-chrome-launcher karma-spec-reporter npm i -D typescript karma-typescipt karma-typescript-es6-transform npm i -D jasmine-core @types/jasmine karma-jasmine 3. Setup the karma config file # this should do
// karma.conf.js module.exports = function (config) { config.set({ frameworks: [\u0026#34;jasmine\u0026#34;, \u0026#34;karma-typescript\u0026#34;], files: [ \u0026#34;src/**/*.ts\u0026#34;, \u0026#34;test/**/*.ts\u0026#34; ], preprocessors: { \u0026#34;**/*.ts\u0026#34;: \u0026#34;karma-typescript\u0026#34; }, reporters: [\u0026#34;progress\u0026#34;, \u0026#34;karma-typescript\u0026#34;], browsers: [\u0026#34;Chrome\u0026#34;], karmaTypescriptConfig: { tsconfig: \u0026#39;tsconfig.callitwhatyouwant.json\u0026#39;, bundlerOptions: { transforms: [ require(\u0026#34;karma-typescript-es6-transform\u0026#34;)() ] } }, singleRun: true }); }; 4. Setup the package json # Nothing really.
\u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;karma start\u0026#34;, } That\u0026rsquo;s it. Nothing else is required in that file.
5. Write code \u0026amp; tests # Write them under src/ and test/ respectively.
`}),e.add({id:8,href:"/angular/services/",title:"Services",section:"Angular",content:` Services (do STUFF) # They are classes where you can put business logic for components. They should be specific. Components and services should be as reusable as possible. This is a good, short read about them: Services and DI.
According to that page linked above:
A component can delegate certain tasks to services, such as fetching data from the server, validating user input, or logging directly to the console
Creating them # You usually create one in a .service.ts file. It is an exported class with functions which perform the required business actions. It can then be injected into the required classes. It might depend on other services too.
Providers tell injectors how to obtain or create the required dependencies.
Using them # Services don\u0026rsquo;t just need to be provided in modules or the root, it\u0026rsquo;s also possible to provide a service object just for a component by setting the providers property in the component metadata.
Read more about dependency injection here.
TODO: Read this to learn how they are used: https://angular.io/guide/providers.
`}),e.add({id:9,href:"/angular/directives/",title:"Directives",section:"Angular",content:` Directives: Hmmm \u0026hellip; # These are just classes that add extra behavior to elements ~ Angular docs.
Components are represented in HTML as elements. Directives are represented as attributes on those elements. A directive can also be applied on a simple HTML element, not just components.
Creating them # You can create a directive class in a file like nice.directive.ts like so:
import { Directive, OnInit } from \u0026#39;@angular/core\u0026#39; Directive({ selector: \u0026#39;\u0026#39; // CSS style selector e.g. [nice-stuff] // the HTML would be like \u0026lt;somecomp nice-stuff\u0026gt;\u0026lt;/somecomp\u0026gt; }) export class NiceDirective { } They need to be added to the declaration section of the ngModule where they will be used. They can get a reference to the element they were used on via the ElementRef service which can be added as a dependency.
Raw access to the DOM element can be gotten via the ElementRef object like so: ref.nativeElement.
Passing values to it # To pass in some value you just set the value of the attribute. E.g. for a directive with a selector \u0026ldquo;sneaky-wookie\u0026rdquo;, do this: \u0026lt;div sneaky-wookie=\u0026quot;some nice string\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;. This can then be accessed via an @Input() property like so: @Input('sneaky-wookie') aliasName: string within the directive class.
An alias had to be used since the directive selector had a \u0026lsquo;-\u0026rsquo; in it.
Builtins # Attribute # Some examples are: ngClass ngStyle Structural # Some basic stuff has been covered here in the docs: ngIf ngFor \u0026lt;a *ngIf=\u0026quot;expr\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; is really a shortcut, it expands to: \u0026lt;ng-template [ngIf]=\u0026quot;expr\u0026quot;\u0026gt;\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/ng-template\u0026gt;.
It\u0026rsquo;s possible to have an else block like so:
\u0026lt;a *ngIf=\u0026#34;expr; else theOtherBlock\u0026#34;\u0026gt;first\u0026lt;/a\u0026gt; \u0026lt;a #theOtherBlock\u0026gt;second\u0026lt;/a\u0026gt; If you want to be consistent you could write that as:
\u0026lt;div *ngIf=\u0026#34;expr; then theFirstBlock else theOtherBlock\u0026gt; \u0026lt;a #theFirstBlock\u0026gt;first\u0026lt;/a\u0026gt; \u0026lt;a #theOtherBlock\u0026gt;second\u0026lt;/a\u0026gt; Does using a \u0026lt;div\u0026gt; there seem weird? It\u0026rsquo;s possible to use \u0026lt;ng-container\u0026gt; instead. It doesn\u0026rsquo;t even get output into the final HTML Want to have an index while looping with ngFor? Do this:
\u0026lt;div *ngFor=\u0026#34;let item of items; let i=index\u0026#34;\u0026gt;{{i + 1}} - {{item.name}}\u0026lt;/div\u0026gt; When the list that ngFor is rendering changes, it\u0026rsquo;s possible to optimize the rendering by only rendering the elements that have changed (modified / removed / added). This is done with trackBy:
\u0026lt;div *ngFor=\u0026#34;let item of items; trackBy: (i, d) =\u0026gt; d.id\u0026#34;\u0026gt; ({{item.id}}) {{item.name}} \u0026lt;/div\u0026gt; ngFor has a bunch of local variables which can help reduce template code. They can be found in the docs but here is an example:
\u0026lt;li *ngFor=\u0026#34;let user of users; index as i; count as c\u0026#34;\u0026gt; {{user.name}} is {{i}} out of {{c}} in the list \u0026lt;/li\u0026gt; Attribute # How to make a custom one!
Start off with ng generate directive somecoolstuff. The base may not be enough, so set it up like this:
import { Directive, ElementRef, HostListener } from \u0026#39;@angular/core\u0026#39;; @Directive({ selector: \u0026#39;[appSomecoolstuff]\u0026#39; }) export class SomecoolstuffDirective { constructor(private el: ElementRef) { // can access DOM node with el.nativeElement } @HostListener(\u0026#39;click\u0026#39;) handler() { // do stuff to the element } } It can be added to an element like this: \u0026lt;a appSomecoolstuff\u0026gt;\u0026lt;/a\u0026gt;. Multiple values can be passed to it using @Input() e.g.:
@Input() randomProp1: string; @Input() randomProp2: number; which can be used like so: \u0026lt;a appSomecoolstuff randomProp1=\u0026quot;wowcool\u0026quot; [randomProp2]=\u0026quot;1+2\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;.
Structural # These modify the DOM by adding / removing elements. Only one structural directive can be applied per element. It\u0026rsquo;s possible to make your own like so: ng g directive whatADirective. The class can be modified like this:
import { Directive, Input, TemplateRef, ViewContainerRef } from \u0026#39;@angular/core\u0026#39;; @Directive({ selector: \u0026#39;[appWhatADirective]\u0026#39;}) export class WhatADirectiveDirective { private someStuff = \u0026#39;wow\u0026#39;; constructor( private templateRef: TemplateRef\u0026lt;any\u0026gt;, private viewContainer: ViewContainerRef ) { } @Input() set appWhatADirective(randomStuff: string) { // do some stuff to the view container } } which can then be used like so:
\u0026lt;p *wow=\u0026#34;\u0026#39;somestring\u0026#39;\u0026#34;\u0026gt; maybe do something with this content here? \u0026lt;/p\u0026gt; The translation between structural directive shortcuts and what Angular actually does can be found here
`}),e.add({id:10,href:"/angular/routing/",title:"Routing",section:"Angular",content:` Routing \u0026amp; Co. # Some modern apps, like the one built with Angular are Single Page Apps. They only load one HTML file from the server (index.html mostly) and then use JS to fetch new content and change parts of the page as the user navigates the site. It behaves like a regular sites in all aspects (look at the address bar) while being more efficient!
Creating routes # Routes are defined as an array of objects. The array is of the type Routes from \u0026ldquo;@angular/router\u0026rdquo;.
The object should be like: {path:'', component: ComponentKlass} which is of type Route. You then pass the array as an argument to RouterModule.forRoot(routes) in an NgModule of your app (e.g. AppModule in app.module.ts) If you want a route to redirect, you can set it like so: {path:'blue', redirectTo: '/red', pathMatch: 'full'} A good practice is to create a separate module for routing and then import the module in AppModule. This way, routes and the RouterModule import will be in a separate file e.g. app-routing.module.ts. The main AppModule may also choose to export the new router module you created so it will be available throughout the app.
Route parameters # You can pass parameters in a route path, like so: path: 'warehouse/:id' where \u0026ldquo;id\u0026rdquo; is the parameter. To access it within your component code you should:
Add ActivatedRoute as a dependency to your component Access the parameter via the dependency object, like so: route.snapshot.params[\u0026quot;id\u0026quot;] Angular does not reload a component when only the parameters change. This can cause issues while navigating from a component to itself. A better idea to subscribe to the params like so:
route.params.forEach((param: Param) =\u0026gt; { // logic for updating content }) Links to routes # You want Angular to generate the links to routes, not hardcode them. This is how you do it:
Add the routerLink property to an element. As its value provide an array of path elements, like this: ['where', someParam], which will be joined with \u0026lsquo;/\u0026rsquo; and used. That element will be clickable and will go to that route when clicked. \u0026lt;a\u0026gt; elements will get an href property with the destination route as the value. Navigate with JS # You can also navigate the site, not just by clicking links, but also with JS if required. You just put Router from \u0026ldquo;@angular/router\u0026rdquo; as a dependency and then call routerName.navigate([/* path as an array of strings */])
There\u0026rsquo;s also an Angular service called Location from \u0026ldquo;@angular/core\u0026rdquo; with which you can go back to the previous page. To use it, inject it as a dependency and then do locationObj.back().
Guards # When you don\u0026rsquo;t want a user to visit or leave ceratin routes.
Activation # Used to prevent users from visiting a route unless some condition is satisfied. You can specify the condition via a function or service. You can do it with a service, like so:
Define a service which has a canActivate method that takes in an ActivatedRouteSnap object as a param. This function returns true / false telling if the should be able to accessed. If you want you can do things like navigate to a 404 page from that function. Pass in the service in an array as the value to the canActivate key of the Route object you wish to guard. Like so: {path: 'event/:id', component: EventDetailsComponent, canActivate: [NavigationService]} Deactivation # Used to prevent users from leaving a page (they can always leave by changing the address in the address bar) unless some condition is satisfied. You can do it with a service, or with a function, like so:
Define a function and add it as a provider. This means you need to create a Provider object and register it in the NgModule\u0026rsquo;s providers array. It needs the provide property which is a string that you can use to access this provider and useValue property whose value the function you just defined. An example: {provide: 'dontLoseData', useValue: checkBadDataState}. The function must return true / false which determines if the user can leave the page. You can then use this provider by accessing it via its key, like so: {path: 'event/new', component: abc, canDeactivate: ['dontLoseData']} Active route # You can add classes to elements which have [routerLink] when the current page is that link. That\u0026rsquo;s done with routerLinkActive='someKlass' property. To match exactly, you can set [routerLinkActiveOptions] to {exact: true}
Lazy loading a Module # You can lazy load a module so that it only loads under a particular route. Therefore it saves bandwidth for the user when they just visit the main site. You define the module, its routes, and its components normally. Some changes:
You import and use CommonModule instead of BrowserModule in NgModule. You use RouterModule.forChild instead of RouterModule.forRoot. Then to load this particular module on a route you can define it in the main route, like so:
{ // this is a Route object path: \u0026#39;extraa\u0026#39;, loadChildren: () =\u0026gt; import(\u0026#39;extraStuff.module\u0026#39; /*the file where the module is defined*/).then( mod =\u0026gt; mod.FancyModule // the NgModule\u0026#39;d class ) } To improve perceived performance, this module can be prefetched whenever the browser is free. This can be done by adding another argument to the root router module like so:
@NgModule({ imports: [ // other modules RouterModule.forRoot(mainRoutes, {preLoadingStrategy: PreLoadAllModules}) ] }) Prefetching with resolve # When a user visits a route a resolver loads the data required for the page before the component is loaded. It helps fix issues caused when the component is ready but the data required for its content is not.
A resolver is usually a service that has a resolve method that takes in an ActivatedRoute object and returns an Observable. The observable is automatically subscribed to.
In the list of routes, for a Route object, specify a resolve property that is equal to an object where the keys can be used to access the data on the route later on. Like so: resolve: { users: getUsersService }. This can then be accessed via the ActivatedRoute like so: this.route.snapshot.data['users']
Nested routes # TODO
Extra options you can set on \u0026lt;router-outlet\u0026gt; # TODO
`}),e.add({id:11,href:"/angular/forms/",title:"Forms",section:"Angular",content:` Forms and validation # There are two kinds of forms in Angular:
Template based (the content and the logic is in the HTML) Model based A.K.A. Reactive (the content and logic is in the component) Creating a form # You need the FormModule from \u0026ldquo;@angular/forms\u0026rdquo; to be imported in the module where you will be using forms. When you import that module, it adds an NgForm directive to all form tags. The directive instance can be accessed as described below. In the component with the form, on the form element, set a template reference variable like so: \u0026lt;form #someNiceNameForForm=\u0026quot;ngForm\u0026quot;\u0026gt;\u0026lt;/form\u0026gt;. This provides additional functionality as described in the docs. For each input element whose value you want, set the name attribute. This will be the key to access its value later on. For the submit action, prefer to bind to ngSubmit instead of using the submit button, like so: \u0026lt;form #formTempVar=\u0026quot;ngForm\u0026quot; (ngSubmit)=\u0026quot;handlerFunc(formTempVar.value)\u0026quot;\u0026gt;\u0026lt;/form\u0026gt; The value prop. on the temp-ref-var is an object where the value for each input field with a name attr. is available. You can also bind ngModel (which is a directive) on each input element to bind it to values on the component, like so: \u0026lt;input (ngModel)=\u0026quot;compoProp\u0026quot; id=\u0026quot;foo\u0026quot; type=\u0026quot;text\u0026quot;\u0026gt;. To achieve two way data binding you can do this: [(ngModel)]=\u0026quot;compoProp. Validation # Angular turns off the default behaviour of adding the \u0026ldquo;required\u0026rdquo; attribute on input elements. It does provide its own validation features:
formTempRefVar has properties like valid, invalid, touched, dirty etc. So does each input element, under formTempRefVar.controls.inputElementName. Those properties for individual elements can also be accessed via temp-ref-vars like so: \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;woah\u0026quot; #niceHandle=\u0026quot;ngModel\u0026quot;\u0026gt;{{niceHandle.valid}}\u0026lt;/input\u0026gt; Angular also adds classes like ng-valid, ng-touched, and ng-pristine to elements. It also sets ng-submitted on the form element when the form has been submitted. These can be used for styling The form can be reset by calling formTempRefVar.reset() The element\u0026rsquo;s property under formTempRefVar.controls may not be defined initially, therefore, if you want to check if the element is in an invalid state you should do it like this: formTempRefVar.controls.inputElementName?.invalid Reactive forms # Here, the structure of the form and its validation rules are defined in the component itself. It\u0026rsquo;s more flexible and lets you unit test things like validation easily. Here\u0026rsquo;s how you make such a form:
You need the ReactiveFormModule like how template forms need FormModule The form is a property of the component. It is of the type FormGroup. You initialize it in ngOnInit, like so: let username = new FormControl(); let password = new FormControl(); let day = new FormControl(); let month = new FormControl(); let year = new FormControl(); let birthday = new FormGroup({ day: day, month: month, year: year }); this.userLoginForm = new FormGroup({ uname: username, paswd: password, dob: birthday }) The properties of the FormGroup are supposed to be the values you want from the form, or a group of values which are encased in a FormGroups of their own. You must bind the HTML form and input elements like so: \u0026lt;form [formGroup]=\u0026quot;userLoginForm\u0026quot;\u0026gt;\u0026lt;/form\u0026gt; and \u0026lt;input formControlName=\u0026quot;username\u0026quot;\u0026gt;\u0026lt;/input\u0026gt;. In case of grouped values, the group must be bound \u0026lt;div formGroupName=\u0026quot;dob\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; and then the constituent elements like so: \u0026lt;input formControlName=\u0026quot;month\u0026quot;\u0026gt;\u0026lt;/input\u0026gt; You can also add a ngModelGroup attribute so that the form value will be structured so that the input elements within the group will be nested inside an object. A structure like this \u0026lt;div ngModelGroup=\u0026quot;lol\u0026quot;\u0026gt;\u0026lt;input name=\u0026quot;hi\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; will give a value object like this: { // other fields lol: { hi: \u0026#34;someval\u0026#34; } } Validation (reactive form) # The format for a new FormControl is: new FormControl(value the field should have, validation for the field) where both params are optional An example validation, where you can mark a field as required is: FormControl(userName, Validators.required) where Validators must be imported from \u0026ldquo;@angular/forms\u0026rdquo; The state of the form is accessible from the primary FormGroup like so: this.userLoginForm.valid To use multiple validators, pass them as an array: [Validators.required, Validators.pattern('ab*')] The results of each validator (pass / fail) can be obtained like userLoginForm.controls.elementName.errors.whatEverValidation where the validation is something like required or pattern or something else. Custom validator # A validator is a function. It returns an error object if the validation failed else it returns null. The error object looks like this: {'errorName': errorValue}. The error value can then be accessed like elementName.errors.errorName. The only argument that the function takes is a FormControl object (which will be the element on which the validator is set).
Super custom validator # You can also use a directive as a validator. Since it is a class it needs to implement Validator from \u0026lsquo;@angular/forms\u0026rsquo; which means it needs to have a function validate that takes in a FormGroup (or FormControl depending on where the directive is used) and return null if there are no errors else an error object like before.
Since it is a directive it needs to be imported in the ngModule. To add it to Angular\u0026rsquo;s list of validators (and therefore make it available for use) you can do this:
import { NG_VALIDATORS } from \u0026#39;@angular/forms\u0026#39; @Directive({ selector: \u0026#39;wow-nice\u0026#39; providers: [{ provides: NG_VALIDATORS, useExisting: NiceValidator, multi: true // this means add this validator as a provider to NG_VALIDATORS }] }) export class NiceValidator { validate(fg: FormGroup) { /* validation logic */} } Multi-field validation # You need to do a few weird things to validate multiple fields:
To access sibling fields, use the root group like so fg.root.controls.siblingElement To actually validate elements with the directive validator you need a temp-ref-var like so: \u0026lt;div ngModelGroup=\u0026quot;niceGrp\u0026quot; validatorDirec #whyNeedIDK=\u0026quot;ngModelGroup\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; The sibling needs to re-run the validator whenever it updates. Can do that with an event binding: \u0026lt;div (change)=\u0026quot;whyNeedIDK.control.controls.someField.upDateValueAndValidity()\u0026gt;\u0026lt;/div\u0026gt; This whole thing is just super complex and weird.
ngModel # TODO: this is one fancy thing. Check out the docs to understand it. There\u0026rsquo;s also this https://angular.io/api/core/ViewContainerRef.
`}),e.add({id:12,href:"/angular/pipes/",title:"Pipes",section:"Angular",content:` Transforming data # Built-in pipes # You can transform data before it is rendered in a template. There are many inbuilt pipes. The format is {{ yourContent | pipeName:pipeArg1 }} where the arguments are JS objects / literals and are optional. Example: \u0026lt;p\u0026gt;A: {{a | currency:'CAD':'code'}}\u0026lt;/p\u0026gt;.
Custom pipe # An example pipe:
// in the file goodie.pipe.ts import {Pipe, PipeTransform} from \u0026#39;@angular/core\u0026#39; @Pipe({ name: \u0026#39;goodiepipe\u0026#39; // the name used to call the pipe in the template }) export class GoodiePipe implements PipeTransform { // this is the function that is called with the args transform(input: string, arg1: number) { if(arg1 \u0026lt; 5) return input+\u0026#34; is low\u0026#34;; return input+\u0026#34; is high\u0026#34;; } } You must then add it to the declarations of the NgModule where you want to use it. It can then be used like so: {{ someVar | goodpipe:32 }}
Filter and Sort # AngularJS had the ability to do this with pipes. This meant that every time the data changed (i.e. a change detection cycle), the pipe would have to be called. This was slow.
Angular doesn\u0026rsquo;t recommend that you sort or filter with pipes (you usually can\u0026rsquo;t but there\u0026rsquo;s the option to do it with impure pipes). It is recommended to sort / filter in the component itself.
Angular only runs a pipe when the identity of the data has changed. It\u0026rsquo;s value. It does not check if the reference has changed. Therefore, if you change the properties of an object, Angular will not run the pipe for it.
Async # You can subscribe and process values from RxJS observables within the template itself. This is possible via the async pipe. It\u0026rsquo;s often used with ngFor like this: \u0026lt;div *ngFor=\u0026quot;let book of books | async\u0026quot;\u0026gt;We have {{ book.name }}\u0026lt;/div\u0026gt; where books is an observable which has multiple next calls and a complete call.
When the component gets destroyed, it automatically unsubscribes from the observable.
Purity # By default, pipes are pure. Pipes use data binding, Angular executes the pipe when a change is detected in the input value.
Pure pipes execute on pure changes (e.g. an object\u0026rsquo;s reference itself changed or a primitive\u0026rsquo;s value changed).
If a pipe is declared as impure, it will execute on all pure changes to the input as well as changes to the input object\u0026rsquo;s properties. Since this can happen often, it is recommended to make impure pipes performant.
`}),e.add({id:13,href:"/angular/di/",title:"Dependency Injection",section:"Angular",content:` Adding features! 🙌 # TODO: add stuff from this: https://angular.io/guide/hierarchical-dependency-injection and try to move most of the service related stuff to the services page.
Dependency injection # This is how you provide new components with extra resources they need to function. To indicate that a class (any class, not just a component / service) has a dependency or is a dependency you decorate it with @Injectable(). From the docs
The injector is the main mechanism. Angular creates an application-wide injector for you during the bootstrap process, and additional injectors as needed. You don\u0026rsquo;t have to create injectors.
An injector creates dependencies, and maintains a container of dependency instances that it reuses if possible.
Some important points:
You declare dependencies of a class in its constructor For each dependency, you must have registered a provider with the injector. A provider creates the dependency object when required. (For a service, it can be the service class itself) Again, from the docs listed at the top of the page:
When Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn\u0026rsquo;t yet exist, the injector makes one using the registered provider, and adds it to the injector before returning the service to Angular.
When all requested services have been resolved and returned, Angular can call the component\u0026rsquo;s constructor with those services as arguments.
Register a provider # You can do it in three ways: In @Injectable() # You can specify the provider as the value to the providedIn key in the metadata object. If you specify 'root' one instance will be available to all components. With an NgModule # You specify the providedIn property as the NgModule where you want this service to be available. With a component # You can place it in the providers array in the metadata of a component and it will get its own instance of that service. To use a function as a provider check out this example. It is preferred to provide the service in the root injector unless there\u0026rsquo;s a requirement to make it available only in some ngmodule.
Using InjectToken # This is a way for the injector to find the required provider from the list of available providers. Its an alternative to using a string. Its better since the token is a variable and the compiler will complain if there is another variable with the same name.
Create a new token like this:
import { InjectionToken } from \u0026#39;@angular/core\u0026#39; let SOME_TOKEN = new InjectionToken\u0026lt;retType\u0026gt;(\u0026#39;whatever description you want\u0026#39;); // Its a convention to capitalize the token name // retType is the type of the object that this provider will create // \u0026#34;any\u0026#34; is a good option in case of a third-party object like jQuery Use it to register a new provider. The provide property will be set to SOME_TOKEN. The other prop. e.g. useValue contains the object that you want to provide e.g. jQuery\u0026rsquo;s \$.
The object can now be used via DI like so:
import { Inject } from \u0026#39;@angular/core\u0026#39; import { SOME_TOKEN } from \u0026#39;./something.service\u0026#39; constructor(@Inject(SOME_TOKEN) private jqSelector) {} ngOnInit() { this.jqSelector.doSomething() } useWhat # Alternatives to useValue
The usual way where you put the service class within the providers array of the ngModule is a shorthand for {provider: someGoodClass, useClass: someGoodClass} useExisting lets you use a different, already registered (i.e. existing), provider when the user requests one provider. Something like this: {provider: someGoodClass, useExisting: someShadyClass} useFactory lets you use a function to create an object. This is complex. Check out the docs. `}),e.add({id:14,href:"/whatnext/",title:"/next",section:"Introduction",content:` So much to learn # These sound useful:
Search for \u0026ldquo;TODO\u0026rdquo; in notes and do those parts Get an overview of what design is about from this talk. Learn how to use penpot with their YT tutorials. This walkthrough can give a good idea. Note down points from Brad\u0026rsquo;s Walkthroughs and also Kevin\u0026rsquo;s. Writing documentation. It\u0026rsquo;s useful because that\u0026rsquo;s what people see first and that\u0026rsquo;s how they can contribute and use what you\u0026rsquo;re building. Some points from here and this place which shows you how to start. There are also principles to follow. Common design patterns from a good fcc article Good article on testing. This covers TDD and stuff Angular has its own \u0026ldquo;learn next\u0026rdquo; page in which \u0026ldquo;schematics\u0026rdquo; seems to be something cool. Vue videos to help with the documentation - https://www.youtube.com/playlist?list=PL-lxoPS_1OXV26ktPlpSWhRuocW5vsI8A No rush, gonna add things whenever I feel the need to 🍃
`}),e.add({id:15,href:"/angular/rxjs/",title:"RxJS",section:"Angular",content:` Async \u0026amp; network stuff # Not everything happens right at once in a webapp. It shouldn\u0026rsquo;t wait for certain events when it can execute other things. This is where asynchronous processing is useful. Promises were the preferred way to do it but now there are observables (from rxjs). Promises represent one event that happens in the future while observables represent zero or more events that could happen synchronously or in the future. This particular section is about RxJS and HTTP in Angular.
The docs tells how observables could be used in place of promises.
Good resources for RxJS:
A gist that explains reactive programming A single page crash course giving an overview of RxJS Overview of main concepts. Official docs Video showing off some RxJS stuff live Video about RxJS stuff specific to Angular HTTP # To communicate via HTTP in JS first import HttpClientModule from \u0026ldquo;@angular/common/http\u0026rdquo; into the ngModule of your choice. Wherever required, a dependency of type HttpClient from \u0026ldquo;@angular/common/http\u0026rdquo; can be injected so that HTTP calls can be made with it.
Once you have an object of HttpClient, say http, you can perform calls such as: http.get\u0026lt;T\u0026gt;(url) where T is the type of the response you expect. The result is an Observable\u0026lt;T\u0026gt; which can be subscribed to.
To add query parameters just do string concatenation :). E.g. http.get\u0026lt;T\u0026gt;(url+\u0026quot;?userid=\u0026quot;+searchUserId) 🌴
There\u0026rsquo;s also the delete method and post method. The post method needs a few more args like so: http.post\u0026lt;T\u0026gt;(url, body, options). Where body is an object containing the data you want to give and options is also an object which has properties like HTTP headers.
The observables that the HTTP methods return just pass one value and then complete.
RxJS 💧 # Helps in managing events in a functional programming and asynchronous manner. Its main concepts are:
Observables # An observable is a stream of lazy push-based computations. They can deliver values (zero to infinite) synchronously or asynchronously. Create one like this:
import { Observable } from \u0026#39;rxjs\u0026#39;; const obsv = new Observable(subscriber =\u0026gt; { // a stream of nexts optionally followed by either an error or a complete // e.g. : subscriber.next(anyValue1); subscriber.next(anyValue2); subscriber.next(anyValue3); subscriber.next(anyValue4); // only one of the following two should be there subscriber.error(anyError); subscriber.complete(); }); The observable can then be subscribed to like so:
const subc = obsv.subscribe(value =\u0026gt; { console.log(value); }) The observable can also be stopped like so:
subc.unsubscribe(); // the behaviour of the function can be customized // by setting the return value of the subscription function const custom = new Observable(subscriber =\u0026gt; { // do some computation return function unsubscribe() { // do clean up perhaps? } }); Observables can be used in HTML templates. As a convention append a \u0026ldquo;\$\u0026rdquo; while naming an observable so that it is distinguishable in the template.
There can be multiple subscribers. Each one will get the same stream of data. An observable may complete before some async operations within it have run. All subscribers will receive same series of next, error and complete events as each other. When one of them unsubscribes, it stops the flow of data to only that one. Observer # A consumer of an observable. Its just an object like this:
const observer = { next: value =\u0026gt; console.log(\u0026#39;Got a value: \u0026#39; + value), error: err =\u0026gt; console.log(\u0026#39;Finished with an error: \u0026#39; + err), complete: () =\u0026gt; console.log(\u0026#39;Finished peacefully\u0026#39;); }; const subc = obsv.subscribe(observer); Some or all properties can be ignored
Subscriptions # They are the objects returned on subscribing to an observable. They essentially have only 3 methods:
unsubscribe(): stop receiving data from the observable add(otherSubscription): so that unsubscribing this subscription will unsubscribe the other one too remove(otherSubscription): to undo the add method described above Operators # Easy to use resource to figure out what kind of operator you need.
They transform the data produced by observables. They are functions. There are two kinds: Creation # They generate observables from some kind of data / instruction. These functions return observables. An example is of from \u0026lsquo;rxjs\u0026rsquo;. It takes in one or more arguments and then creates an observable that pushes these objects one after the other. Pipeable # They generate observables from other observables. These functions return functions that take in an observable and return an observable. An example is map from \u0026lsquo;rxjs/operators\u0026rsquo;. You use it like let funk = map(x =\u0026gt; x+x) and then outputObsv = funk(inputObsv). The official docs has a useful list of commonly used observables, grouped by category.
Many times multiple pipeable operators are used in sequence. It becomes messy, thus we have the pipe function which can be used like this:
const obsv = of(1, 2, 3); const obsv1 = map(x =\u0026gt; x * x)(obsv); const obsv2 = filter(y =\u0026gt; y \u0026gt; 3)(obsv1); obsv2.subscribe(v =\u0026gt; console.log(v)); // is equivalent to const subscrip = of(1, 2, 3).pipe( map(x =\u0026gt; x * x), filter(y =\u0026gt; y \u0026gt; 3) ).subscribe( v =\u0026gt; console.log(v) ); Subjects # An observerable that can also be used as an observer. They can be used to make an observable multicast (They are unicast by default). Using it as an observable:
import { Subject } from \u0026#39;rxjs\u0026#39;; const obsv = new Subject\u0026lt;any\u0026gt;(); // the default type is void obsv.subscribe(/* an observer */); obsv.next(someVal1); obsv.next(someVal2); obsv.complete(); It can also be used as an observer. Just pass the Subject object to an observer\u0026rsquo;s subscribe method. This works since the Subject already has next, error, and complete methods.
The important difference between a subject and a normal observable is that a subject does not maintain separate execution contexts. A normal observer creates an independent execution context for each observer it has. Whenever an observer subscribes to a subject it can receive values from there on only. Not the old values. There are specialized subscribers that can buffer some old values to give new observers. A cool trick is to make an observable multicast with a subject. Like so:
import { of, Subject } from \u0026#39;rxjs\u0026#39; const obsv = of([1, 2, 3, 4, 5]); const sub = new Subject\u0026lt;number\u0026gt;(); const scp1 = sub.subscribe(e =\u0026gt; console.log(e)); const scp2 = sub.subscribe(e =\u0026gt; console.log(e)); obsv.subscribe(sub); Some useful specialized subjects:
BehaviourSubject # Holds the current value that was pushed. When new observers subscribe, they immediately get that value. Afterwards they continue to get pushed values like other old observers.
ReplaySubject # A generalized form of BehaviourSubject. It can hold a buffer of n previously pushed values and pass them at once to new observers. They are used like this: const sub = new ReplaySubject\u0026lt;number\u0026gt;(bufferSize, expirationTimeForEachValue [optional])
Void Subject # This is the default type of subject created when no type is specified. The subscriber for this doesn\u0026rsquo;t receive any values for its next function. It\u0026rsquo;s useful when you just want to know that some event occured.
Scheduler # Controls when subscriptions start. Can modify this so that subscriptions start immediately, on the next event loop, next micro loop, or after some timeout. This is kinda complex so here\u0026rsquo;s a link to the docs.
`}),e.add({id:16,href:"/angular/test/",title:"Testing",section:"Angular",content:` Unit \u0026amp; Integrated tests # Angular uses Jasmine for unit testing and Karma to run the tests on browsers. Tests can be:
Isolated # Only tests the JS class not the component Mostly used for services and pipes Need to create instances of classes on your own Integrated # Tests the class and template together Mostly used for components and directives The objects are created by the framework Unit tests # They test a single unit (like a class, function, or a bunch of classes) in isolation. Some features of unit tests:
Fast (to code and to execute) Should handle one state change at max Assert one thing Minimal dependencies They follow a structure of:
Assemble - The setup code for the test Action - The thing that the user will likely do. Can be a state change Assert - \u0026ldquo;Is the result what is expected?\u0026rdquo; Run unit tests with ng test which asks Karma to look for *.spec.ts files and execute the tests within them. A basic test looks like this:
describe(\u0026#39;a nice test\u0026#39;, () =\u0026gt; { // do something beforeEach(() =\u0026gt; { // code to run before each \u0026#39;it\u0026#39; }) it(\u0026#39;exact test stuff\u0026#39;, () =\u0026gt; { // do something expected(valA).toBe(\u0026#39;good stuff\u0026#39;); }) }) toBe is just one of the many \u0026ldquo;matchers\u0026rdquo; jasmine has. The official docs has a list of matchers Mocking # To minimize depedencies on external code they are mocked for things like network calls, DB use, side effects etc. E.g. instead of making HTTP requests with the http dependency use a mock http dependency that simulates network calls and returns results immediately.
Mock with jasmine like this: const mockStuff jasmine.createSpyObj('some desc', ['method1', 'method2', 'method3']). A particular method can be modified to return a particular value like this: mockStuff.method1.and.returnValue(anyValue) To check if a method is being called in the function with particular params, use: expect(mockStuff.method2).toHaveBeenCalledWith(param1, param2) where the parameters can be exact values or it can just check that the types match by passing in an arg like jasmine.any(ClassName) Components can be tested just like services for isolated tests. Instantiate the class with mock dependencies, set any input params and then test whatever methods needed to be tested. Integrated tests # They\u0026rsquo;re more complex and are meant to test an entire functionality. It can test the template and the component in an environment that\u0026rsquo;s a close approximation to real world usage.
Setup # This is more complex since Angular creates the instances of the component and template and places them in a module. This setup goes in a beforeEach. The code for this is usually generated by the cli when using ng g c and is placed in \u0026ldquo;*.component.spec.ts\u0026rdquo;. It looks like this:
// inside a describe callback let component: NiceComponent; // the type let fixture: ComponentFixture\u0026lt;NiceComponent\u0026gt;; // from \u0026#34;@angular/core/testing\u0026#34; let debugEl: DebugElement; // handle to the template let rawHTML: HTMLElement; // handle to the raw html of the template let mockThatService; // mock object for a dependency beforeEach(() =\u0026gt; { // if you don\u0026#39;t want complex functionality no need to use a spyObj // a simple object with the props required will do mockThatService = {}; // creates the module where the component will run TestBed.configureTestingModule({ declarations: [ component ], providers: [ { provide: ThatService, useValue: mockThatService } ] }); fixture = TestBed.createComponent(NiceComponent); component = TestBed.componentInstance; debugEl = TestBed.debugElement; rawHTML = TestBed.nativeElement; // runs change detection so the template is kept updated with the component fixture.detectChanges(); }) Deep \u0026amp; Shallow tests # A shallow integration test just includes the component that is being tested while a deep test will also include the necessary children component (but may not test them). A deep test is heavy because of dependencies but it is complete.
When using a shallow test, it is possible to ignore the errors caused by dependencies on other components. This is done by adding a schema to the testing module like so:
TestBed.configureTestingModule({ declarations: [/* wtv */], providers: [/* wtv */], schemas: [ NO_ERRORS_SCHEMA // from angular core ] }) Debugging # This can be a pain. Here are some tools to help:
Augury can present info neatly in dev tools. ngx-logger is a nice logger apparently. Put debugger in your TS code so it can be paused in the browser. `}),e.add({id:17,href:"/angular/libraries/",title:"Libraries",section:"Angular",content:` Ultra level reusability # They provide extra functionality to Angular. They don\u0026rsquo;t run on their own. They need to be used in an application. There are many first party libraries that are regularly used, like \u0026ldquo;@angular/forms\u0026rdquo;.
Angular libraries (e.g. the @angular/x ones) are NgModules.
Some functionality of an app can be packaged into a library so it can be reused with other apps. They can then be published in \u0026ldquo;npm\u0026rdquo; or wherever.
Installing them # Install via npm like so: npm i jquery. If the library does not contain typings for typescript within in a .d.ts file you can try to get them via npm i @types/jquery. It can then be use like so: import * as \$ from jquery
You can also define types on your own via a .d.ts file e.g. cooltypes.d.ts in src/ where you delcare interfaces and functions.
An alternate way to use them is to put them in the global scope as if they were put in a script tag. That\u0026rsquo;s done by adding the source to the scripts array in angular.json
Creating one # It\u0026rsquo;s a convention to prefix library names with ngx- to denote they are Angular libs.
TODO: I don\u0026rsquo;t understand this. Gotta do it later.
`}),e.add({id:18,href:"/shortcodes/",title:"theme-guide",section:"Introduction",content:` Buttons # Buttons are styled links that can lead to local page or external link.
Example # {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home Contribute Columns # Columns help organize shorter pieces of content horizontally for readability.
{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example # Left Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia. Mid Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Right Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia. Details # Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.
Example # {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title Markdown content # Lorem markdownum insigne\u0026hellip; Hints # Hint shortcode can be used as hint/alerts/notification block.
There are 3 colors to choose: info, warning and danger.
{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example # Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Tabs # Tabs let you organize content by context, for example installation instructions for each supported platform.
{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example # MacOS MacOS # This is tab MacOS content.
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.
Linux Linux # This is tab Linux content.
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.
Windows Windows # This is tab Windows content.
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.
`}),e.add({id:19,href:"/credits/",title:"/credits",section:"Introduction",content:` Credits # Built with HUGO Uses the hugo-book theme Compass icon by Icons8 You can find the source for this site on GitHub.
A small guide to shortcodes within this theme:
Theme Guide `})})()