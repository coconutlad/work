---
title: "D3"
weight: 1
# bookFlatSection: false
# bookCollapseSection: false
# bookComments: true
---

# Data Driven Docs?
While it's a good library overall, I'm learning how to make network graphs with it.
Here goes nothing ðŸ˜›

Oooh, this is one crazy library with a heck lot of things it can do. Nice confusion.
These might be some good resources:
* [Official tutorial](https://observablehq.com/@d3/learn-d3)
* [Huge collection of tutorials](https://github.com/d3/d3/wiki/Tutorials)
* I like Pluralsight. Videos can be helpful y'know.
[This course seems updated](https://app.pluralsight.com/library/courses/d3-data-visualization-fundamentals/table-of-contents)
* [An updated D3 tutorial](https://www.d3indepth.com/) (taken from the GitHub list) should also help!

## Selection

## Random code (iykyk)
```js
import './styles.css';
import * as d3Base from 'd3';
import * as d3Dag from 'd3-dag';

const nodeRadius = 20,
  edgeRadius = 5;
const d3 = Object.assign({}, d3Base, d3Dag);
const sources = {
  Zherebko: ['zherebko', d3.dagConnect()],
  Grafo: ['grafo', d3.dagStratify()],
  'X-Shape': ['ex', d3.dagStratify()]
};

function gridTweak(layout) {
  return (dag) => {
    // Tweak allows a basis interpolation to curve the lines
    // We essentially take the three point lines and make them five, with two points on either side of the bend
    const { width, height } = layout(dag);
    for (const { points } of dag.ilinks()) {
      const [first, middle, last] = points;
      if (last !== undefined) {
        points.splice(
          0,
          3,
          first,
          {
            x: middle.x + Math.sign(first.x - middle.x) * nodeRadius,
            y: middle.y
          },
          middle,
          { x: middle.x, y: middle.y + nodeRadius },
          last
        );
      }
    }
    return { width, height };
  };
}

function gridCompact(layout) {
  return (dag) => {
    // Tweak to render compact grid, first shrink x width by edge radius, then expand the width to account for the loss
    // This could alos be accomplished by just changing the coordinates of the svg viewbox.
    const baseLayout = layout.nodeSize([
      nodeRadius + edgeRadius * 2,
      (nodeRadius + edgeRadius) * 2
    ]);
    const { width, height } = baseLayout(dag);
    for (const node of dag) {
      node.x += nodeRadius;
    }
    for (const { points } of dag.ilinks()) {
      for (const point of points) {
        point.x += nodeRadius;
      }
    }
    return { width: width + 2 * nodeRadius, height: height };
  };
}

function arrayEq(left, right) {
  return left.length === right.length
    ? left.every((v, i) => v === right[i])
    : false;
}

function leftLane(nodes) {
  for (const node of nodes) {
    node.x = undefined;
  }

  let lane = 0;
  let prev = undefined;
  const parents = new Map(nodes.map((n) => [n, []]));
  for (const node of nodes) {
    if (prev !== undefined && !arrayEq(parents.get(node), [prev])) {
      lane++;
    }
    node.x = lane;

    for (const child of node.ichildren()) {
      parents.get(child).push(node);
    }
    prev = node;
  }

  for (const node of nodes) {
    node.x = lane - node.x;
  }
}

const algorithms = {
  Grid: {
    'Top Down': gridTweak(gridCompact(d3.grid())),
    'Bottom Up': gridTweak(
      gridCompact(d3.grid().lane(d3.laneGreedy().topDown(false)))
    ),
    Open: gridTweak(gridCompact(d3.grid().lane(leftLane))),
    'Optimal (slow)': gridTweak(gridCompact(d3.grid().lane(d3.laneOpt())))
  },
  Zherebko: {
    Greedy: d3
      .zherebko()
      .nodeSize([nodeRadius * 2, (nodeRadius + edgeRadius) * 2, edgeRadius * 2])
  },
  Sugiyama: {
    Fast: d3
      .sugiyama()
      .layering(d3.layeringTopological())
      .coord(d3.coordTopological())
      .nodeSize((d) =>
        d === undefined
          ? [edgeRadius * 2, 0]
          : [nodeRadius * 2, (nodeRadius + edgeRadius) * 2]
      ),
    Slow: d3
      .sugiyama()
      .layering(d3.layeringTopological())
      .decross(d3.decrossOpt())
      .coord(d3.coordTopological())
      .nodeSize((d) =>
        d === undefined
          ? [edgeRadius * 2, 0]
          : [nodeRadius * 2, (nodeRadius + edgeRadius) * 2]
      )
  }
};

const [key, reader] = sources['Zherebko'];

async function renderit() {
  const dag_data = await d3.json(
    `https://raw.githubusercontent.com/erikbrinkman/d3-dag/master/examples/${key}.json`
  );
  // const dag_data = [
  //   ['1', '3'],
  //   ['2', '3'],
  //   ['3', '4']
  // ];
  console.log(dag_data);
  const dag = reader(dag_data);
  const baseLayout = algorithms['Zherebko']['Greedy'];
  const layout = (dag) => {
    const { width, height } = baseLayout(dag);
    for (const node of dag) {
      [node.x, node.y] = [node.y, node.x];
    }
    for (const { points } of dag.ilinks()) {
      for (const point of points) {
        [point.x, point.y] = [point.y, point.x];
      }
    }
    return { width: height, height: width };
  };
  const start = performance.now();
  const { width, height } = layout(dag);
  const time = performance.now() - start;
  console.log(time);

  const svgSelection = d3
    .select('svg')
    .attr('width', width)
    .attr('height', height);
  const defs = svgSelection.append('defs'); // For gradients

  const steps = dag.size();
  const interp = d3.interpolateRainbow;
  const colorMap = {};
  for (const [i, node] of [...dag].entries()) {
    colorMap[node.data.id] = interp(i / steps);
  }

  // How to draw edges
  const curveStyle = {
    Grid: [d3.curveBasis, d3.curveBasis],
    Zherebko: [d3.curveMonotoneY, d3.curveMonotoneX],
    Sugiyama: [d3.curveNatural, d3.curveNatural]
  }['Zherebko'][1];
  const line = d3
    .line()
    .curve(curveStyle)
    .x((d) => d.x)
    .y((d) => d.y);

  // Plot edges
  svgSelection
    .append('g')
    .selectAll('path')
    .data(dag.links())
    .enter()
    .append('path')
    .attr('d', ({ points }) => line(points))
    .attr('fill', 'none')
    .attr('stroke-width', 3)
    .attr('stroke', ({ source, target }) => {
      // encode URI component to handle special characters
      const gradId = encodeURIComponent(`${source.data.id}-${target.data.id}`);
      const grad = defs
        .append('linearGradient')
        .attr('id', gradId)
        .attr('gradientUnits', 'userSpaceOnUse')
        .attr('x1', source.x)
        .attr('x2', target.x)
        .attr('y1', source.y)
        .attr('y2', target.y);
      grad
        .append('stop')
        .attr('offset', '0%')
        .attr('stop-color', colorMap[source.data.id]);
      grad
        .append('stop')
        .attr('offset', '100%')
        .attr('stop-color', colorMap[target.data.id]);
      return `url(#${gradId})`;
    });

  const arrowSize = (nodeRadius * nodeRadius) / 5.0;
  const arrowLen = Math.sqrt((4 * arrowSize) / Math.sqrt(3));
  const arrow = d3.symbol().type(d3.symbolTriangle).size(arrowSize);
  svgSelection
    .append('g')
    .selectAll('path')
    .data(dag.links())
    .enter()
    .append('path')
    .attr('d', arrow)
    .attr('transform', ({ source, target, points }) => {
      const [end, start] = points.slice().reverse();
      // This sets the arrows the node radius (20) + a little bit (3) away from the node center, on the last line segment of the edge. This means that edges that only span ine level will work perfectly, but if the edge bends, this will be a little off.
      const dx = start.x - end.x;
      const dy = start.y - end.y;
      const scale = (nodeRadius * 1.15) / Math.sqrt(dx * dx + dy * dy);
      // This is the angle of the last line segment
      const angle = (Math.atan2(-dy, -dx) * 180) / Math.PI + 90;
      console.log(angle, dx, dy);
      return `translate(${end.x + dx * scale}, ${
        end.y + dy * scale
      }) rotate(${angle})`;
    })
    .attr('fill', ({ target }) => colorMap[target.data.id])
    .attr('stroke', 'white')
    .attr('stroke-width', 1.5)
    .attr('stroke-dasharray', `${arrowLen},${arrowLen}`);

  // Select nodes
  const nodes = svgSelection
    .append('g')
    .selectAll('g')
    .data(dag.descendants())
    .enter()
    .append('g')
    .attr('transform', ({ x, y }) => `translate(${x}, ${y})`);

  // Plot node circles
  nodes
    .append('circle')
    .attr('r', nodeRadius)
    .attr('fill', (n) => colorMap[n.data.id]);

  // Add text to nodes
  nodes
    .append('text')
    .text((d) => d.data.id)
    .attr('font-weight', 'bold')
    .attr('font-family', 'sans-serif')
    .attr('text-anchor', 'middle')
    .attr('alignment-baseline', 'middle')
    .attr('fill', 'white');
}
renderit();

```

HTML Stuff: Just put an svg tag in some div somewhere.