'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/angular/',title:"Angular",section:"Docs",content:"Angular, the fancy web framework #  I gotta use this for work lol. I heard that some people hate it. Not my problem. If it works, it works.\nBase #  Where am I starting from? Why is that important? It defines what kind of content will be in this manual. I know nothing about Angular. I know a bare minimum of HTML, CSS, and JS. üò∞ let\u0026rsquo;s see how this goes. YOLO üôÇ.\nCourse stuff #  I\u0026rsquo;m following along The Angular Fundamentals course on Pluralsight. The authors have nice practice exercises available on their website. Code for the course is available on GitHub.\nThis Crash Course by Traversy Media is also very good.\nFinally, The Angular docs are very good.\nJust to note, the content I put up here is whatever I understood out of the courses and many other sources off the internet. I haven\u0026rsquo;t and I won\u0026rsquo;t, purposefully, rip content off sources I haven\u0026rsquo;t listed here. I try to write this stuff on my own but sometimes, when it comes to things like specs and such, they do need to be put in word for word.\n"}),a.add({id:1,href:'/docs/angular/overview/',title:"Overview",section:"Angular",content:"An overview (and miscellaneous stuff) #  Angular is a platform, apparently, that includes a framework, some libraries, and developer tools to work with all of that. For most purposes, it\u0026rsquo;s called a front-end web development framework.\nTypescript #  Angular uses TS. It\u0026rsquo;s a superset of JS that compiles to JS. You can adding typing via syntactic sugar which helps catch bugs when you compile. It also has editor plugins for the same. You can try it out online. Its main features are:\nStatic typing #  You can declare types while declaring variables, like so: let var: number;.\nInterfaces #  They let you define a structure that objects must follow. An interface is a type. When you assign an object to a variable of that type, the object must have the properties in that interface (each of the same type). Like so\ninterface nice { name: string, age: number } let sic: nice; sic = { name: \u0026#34;hai\u0026#34;, // adding, removing, or changing the types of these properties causes an error  age: 10 }; Class properties #  ES6 classes mainly define their properties via their constructors. TS lets you to define these properties in the class itself. You can optionally specify types for them. This is only for readability. E.g.\nclass Hip { num: number wutdis constructor() { this.num = 10; this.wutdis = \u0026#34;hmm\u0026#34;; } } Public / Private access #  All class properties in ES6 are public. You can make them private in TS by adding the private before them during declaration. It also provides this nifty shorthand for the constructor:\nclass Hip { constructor(public wutdis: string, private num) { // it implicitly does this.wutdis = wutdis  } } let f = new Hip(\u0026#34;sic\u0026#34;, 10); console.log(f); // { wutdis: \u0026#34;sic\u0026#34;, num: 10 } The bootstrap process #   The first file that is run is main.ts (as defined in angular.json That\u0026rsquo;s a very useful file). It bootstraps a module, app/module.ts by default. It bootstraps the root component, app/app.component.ts by default. The root component is placed in app/index.html which is what is rendered.  Deployment üéà #  This is done with the ng build command which:\n Minifies code (removes whitespaces and renames variables) Bundling (merges many JS file into a single JS file) so fewer requests are made Tree shaking (the production app doesn\u0026rsquo;t have code that is never used). It\u0026rsquo;s a little different from dead code elimination.  Angular has an Ahead Of Time (AOT) compiler that converts the HTML of templates into JS code that manupilates the DOM. It can help catch template errors, reduce the output size, and make rendering on the browser faster.\nBy default, running ng build will generate a \u0026ldquo;development\u0026rdquo; build which can still be deployed but isn\u0026rsquo;t as optimized as it could be. To run it in \u0026ldquo;production\u0026rdquo; mode use ng build --prod which reduces the number of requests and file sizes.\nDeployment just involves copying the directory within \u0026ldquo;dist\u0026rdquo; to the web server!\n"}),a.add({id:2,href:'/docs/whatnext/',title:"Whatnext",section:"Docs",content:"So much to learn üòÆ #  I think I should learn these things because they might be useful at work:\n Common design patterns (with examples?) Should add a lifecycle section to Angular? Maybe just link to the docs? Add more content about Angular services (really needed?) TypeScript, since it\u0026rsquo;s the default lang for Angular. Just an overview from a YT video perhaps? Search for \u0026ldquo;TODO\u0026rdquo; in the Angular notes and do those parts For the Angular docs do it in this order: \u0026ldquo;Getting Started\u0026rdquo; -\u0026gt; \u0026ldquo;Tutorials\u0026rdquo; -\u0026gt; \u0026ldquo;Understanding Angular\u0026rdquo; -\u0026gt; \u0026ldquo;Reference/Conceptual Reference\u0026rdquo;  No rush, gonna add things whenever I feel the need to (I believe that is the best way for me to learn) üçÉ.\n"}),a.add({id:3,href:'/docs/angular/components/',title:"Components",section:"Angular",content:"The real CONTENT #  Creating them #  A bare component is a class, defined in a .ts file. You can create new one like this:\n Create a .ts file and export a class that is decorated by Component from @angular/core. The decorator takes in an object as argument. The object has properties like selector (which is a CSS selector to find out which HTML elements this component should apply to) and template (or templateUrl). Import this class in app.module.ts and add it to declarations in the NgModule decorator of AppModule.  Data binding: Accessing the component\u0026rsquo;s properties within its template via the {{ any JS expression }} syntax.\nThe constructor of a component should ideally be empty, put intialization code in ngOnInit.\nCommunicating with a child component #  When you have a child component within your component you can pass data to it via HTML attributes. The process is:\n Create a property on the child component class that is prefixed by the @Input() decorator. E.g. @Input() title: string In the child component\u0026rsquo;s tag in the parent component\u0026rsquo;s template, pass the value like this: \u0026lt;child-comp [title]=\u0026quot;any JS expression\u0026quot;\u0026gt;\u0026lt;/child-comp\u0026gt; You can react to changes in any of the input properties via ngOnChanges(){} You can also set an input propert setter like so: @Input() set propname(val) {} where the function is called every time propname changes. Just like a JS setter.  Communicating with the parent component #  The common patern here is passing along an event to the parent component. It works like this, overall:\n Create an event handler to respond to some event in the child HTML. Just a function property of the class. Like so, handleHere() {} Create an event emitter property that is decorated by Output. Like so, @Output() handledByParent = new EventEmitter() In the even handler you can call handledByParent.emit(anyVal) which will emit an event by the child component In the parent, you can create a handler for the event, like so: \u0026lt;child-comp (handledByParent)=\u0026quot;parentHandler($event)\u0026gt;\u0026lt;/child-comp\u0026gt;. $event is a special keyword that contains the value passed to emit. You can only pass one value. parentHandler is a function property of the parent component.  Styling em #  You can add styles for a component (other than the global styles), in two ways:\n Create an array of strings, where each one can have CSS style rules and assign that to the styles property of the decorator object of the component Add the rules in a file and create an array of strings (with file names) and assing it to styleUrls.  CSS Encapsulation #  When you add CSS styles to your component, it only matches the elements directly in the component. It does not apply to a parent or child component. This is how that works:\nAngular automatically adds attributes to every element within a component. Within a component, they all have the same attribute which is unique to elements in that component. It also modifies the CSS of that component to apply only when that attribute is present.\nThere is a way to pass down styles to children by using a \u0026ldquo;deep\u0026rdquo; selector (google when needed).\nGlobal styles are not mangled like this.\nContent Projection #  AKA \u0026ldquo;How to reuse components\u0026rdquo;. Components have \u0026ldquo;content slots\u0026rdquo; within them. You can reuse a component by putting different content within these slots.\nIf the parent template looks like:\n\u0026lt;h2\u0026gt;Hip hop\u0026lt;/h2\u0026gt; \u0026lt;somechildcomp\u0026gt; \u0026lt;button\u0026gt;woop\u0026lt;/button\u0026gt; \u0026lt;h3\u0026gt;sneak\u0026lt;/h3\u0026gt; \u0026lt;/somechildcomp\u0026gt; The button and the h3 (basically all content within those tags) will be available to the child component via \u0026lt;ng-content\u0026gt;\u0026lt;/ng-content\u0026gt;\nMultiple content slots can be used with multiple ng-contents. This is how you would do it: In the parent template:\n\u0026lt;div someattr1\u0026gt; \u0026lt;!-- stuff for first content slot --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;whodisboi\u0026#34;\u0026gt; \u0026lt;!-- stuff for second content slot --\u0026gt; \u0026lt;/div\u0026gt; The HTML content within those slots can be used like so:\n\u0026lt;header\u0026gt; \u0026lt;ng-content select=\u0026#34;[someattr1]\u0026#34;\u0026gt;\u0026lt;/ng-content\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section\u0026gt; \u0026lt;ng-content select=\u0026#34;#whodisboi\u0026#34;\u0026gt;\u0026lt;/ng-content\u0026gt; \u0026lt;/section\u0026gt; The select attribute of ng-content takes in CSS selectors to match the HTML content from the parent.\nAccessing DOM with viewChild #  To access the DOM of the HTML of a component:\n Give it a temp-ref-var like so: \u0026lt;div #theBestElem\u0026gt;\u0026lt;/div\u0026gt; Create a property on the component decoreated by viewchild like so: viewChild('theBestElem') goodie: ElementRef You can then access its DOM properties or get even more granular control with nativeElement.  Directives #  Components are represented in HTML as elements. Directives are represented as attributes on those elements. A directive can also be applied on a simple HTML element, not just components.\nCreating them #  You can create a directive class in a file like nice.directive.ts like so:\nimport { Directive, OnInit } from \u0026#39;@angular/core\u0026#39; Directive({ selector: \u0026#39;\u0026#39; // CSS style selector e.g. [nice-stuff]  // the HTML would be like \u0026lt;somecomp nice-stuff\u0026gt;\u0026lt;/somecomp\u0026gt; }) export class NiceDirective { } They need to be added to the declaration section of the ngModule where they will be used. They can get a reference to the element they were used on via the ElementRef service which can be added as a dependency.\nRaw access to the DOM element can be gotten via the ElementRef object like so: ref.nativeElement.\nPassing values to it #  To pass in some value you just set the value of the attribute. E.g. for a directive with a selector \u0026ldquo;sneaky-wookie\u0026rdquo;, do this: \u0026lt;div sneaky-wookie=\u0026quot;some nice string\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;. This can then be accessed via an @Input() property like so: @Input('sneaky-wookie') aliasName: string within the directive class.\nAn alias had to be used since the directive selector had a \u0026lsquo;-\u0026rsquo; in it.\n"}),a.add({id:4,href:'/docs/shortcodes/',title:"Shortcodes",section:"Docs",content:"Buttons #  Buttons are styled links that can lead to local page or external link.\nExample #  {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  Columns #  Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example #  Left Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   Details #  Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample #  {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title Markdown content Lorem markdownum insigne\u0026hellip;   Hints #  Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example #  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Tabs #  Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example #  MacOS MacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux Linux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows Windows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n "}),a.add({id:5,href:'/docs/angular/template/',title:"Template Syntax",section:"Angular",content:"The template syntax #  The template builds the HTML content that is displayed for a component. It is HTML with some Angular template syntax which lets you make the component reusable.\nBinding in HTML JS in HTML? There are multiple ways you can use JS objects in HTML. Two of them are:\nInterpolation In places within the HTML where you can put custom values (within tags, properties of attributes, etc) you can use the result of a JS expression like this: \u0026lt;div\u0026gt;{{ some JS expression }}\u0026lt;/div\u0026gt;. All the public properties of the component class are available. The result is always a string. This is because the toString() method is called on the result of the expression. The binding between the class properties and the text is one way. Updates to the property will be reflected in the HTML but not the other way around.\nProperty binding HTML elements have properties e.g. \u0026ldquo;class, style, action, id, nonce, etc\u0026rdquo;. You can set the values of these properties, like so: \u0026lt;div [nonce]=\u0026quot; some JS expression \u0026quot;\u0026gt;\u0026lt;/div\u0026gt;. The result is not converted to a string.\nRules for expressions You can\u0026rsquo;t use a few things, like these:\n Assignment operators The new keyword to create objects ; to use multiple expressions Global namespace objects like console, window, etc.  In general, here are a few guidelines you should follow:\n The expression shouldn\u0026rsquo;t have side effects Try to keep them simple and fast  Event binding HTML elements also have events that they can emit e.g. \u0026ldquo;click, focus, hover, etc\u0026rdquo;. You can bind these events (which means running code when it emitted) to statements, like so: \u0026lt;div (hover)=\u0026quot; some JS statement \u0026quot;\u0026gt;\u0026lt;/div\u0026gt;.\nRules for statements Statements can have assignments but only with =, not += or other stuff. They can have multiple expressions separated by ; but the other restrictions that held for expressions still hold. They mostly do have side effects.\n  Two way binding #  TODO\n*ngFor #  ngFor is a structural directive. That means that it is capable of changing the DOM structure. It works like a for loop, where for each iteration it creates another instance of the element (and its children) on which it is called. It also provides a template reference variable for the element / its children to use. An example below:\n\u0026lt;!-- x is the templ ref var and y is a property of the comp class --\u0026gt; \u0026lt;figure *ngFor=\u0026quot;let x of y\u0026quot;\u0026gt; \u0026lt;img [src]=\u0026quot;x.imzSrc\u0026quot;\u0026gt; \u0026lt;figcaption\u0026gt;{{x.imzCap10}}\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; undefined values #  When you try to access an undefined value within a template, Angular will not display that element and it will throw an error in the console :(. If you are expecting something to be undefined you can use the JavaScript safe navigation operator ?. which returns undefined if its LHS is undefined else goes ahead. Check out the syntax on MDN.\n*ngIf #  ngIf lets you conditionally render the element it is put on. It decides this based on the expression provided to it, like so: \u0026lt;img *ngIf=\u0026quot;some JS expression\u0026quot;\u0026gt;.\nIt is important to note that in case the condition is falsy, the entire element is commented out. It\u0026rsquo;s not just hidden by some CSS / HTML property. In case some operations are done when the element is rendered and it is added / removed multiple times, it can slow down performance.\nIf you want to hide and un-hide the element multiple times you can do so with the HTML attribute \u0026ldquo;hidden\u0026rdquo; which you set like so: \u0026lt;img [hidden]=\u0026quot;some JS expression\u0026quot;\u0026gt;.\n ngSwitch \u0026amp; co #  This is to ngIf like a switch case is to an if condition. You define the switch condition like so: \u0026lt;div [ngSwitch]=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;. On the children you can use either:\n \u0026lt;img *ngSwitchCase=\u0026quot;\u0026quot;\u0026gt; to compare particular JS objects (objects, not just strings) OR \u0026lt;img *ngSwitchDefault\u0026gt; which will come to life if none of the other cases matched  Adding classes #  There are multiple ways to do this. The simple way is for a single property like so: \u0026lt;img [class.klassname]=\u0026quot;bool JS expression\u0026quot;\u0026gt; which will add the class \u0026ldquo;klassname\u0026rdquo; to the element if the expression is truthy.\nWhen you want to add multiple classes you can do so with ngClass like so \u0026lt;img [ngClass]=\u0026quot;fancy stuff\u0026quot;\u0026gt; where \u0026ldquo;fancy stuff\u0026rdquo; can be any JS expression that returns one of these:\n An object, where the keys are class names and values are booleans which decide if that class will be added A string of space separated class names An array of strings, each of which are class names  ngStyle #  You can add CSS styles too similar to classes. ngStyle has a similar syntax to ngClass except that the return value of the expression should be an object where the keys are CSS style keys and values are CSS style values. A small example: HTML element with \u0026lt;img [ngStyle]=\u0026quot;komPute()\u0026quot;\u0026gt;. The function:\nkomPute() { if(/* condition */) return {\u0026#39;background-color\u0026#39;: \u0026#39;red\u0026#39;, display: \u0026#39;inline\u0026#39;}; return {display: \u0026#39;block\u0026#39;}; } Template reference variable #  They help you use one part of a template in another. You can declare a variable on a tag, a component, or a bunch of other things as seen in the docs. For a tag, it is a reference to the TS object of that tag and for a component it a reference to an object of that child component class. If you define one in an ngIf or an ngFor you can\u0026rsquo;t access it outside those boundaries. This is how you use them:\n Declare the variable like this \u0026lt;comp-or-tag #refVar\u0026gt;\u0026lt;/comp-or-tag\u0026gt; You can then use this in other parts of the template, if it\u0026rsquo;s a component you can access its public properties. Like so, \u0026lt;other-tag [lul]=\u0026quot;refVar.val1\u0026quot; (snap)=\u0026quot;refVar.func1()\u0026quot;\u0026gt; {{ refVar.val2 }} \u0026lt;/other-tag\u0026gt; It is not accessible in the TS of the parent component.  "}),a.add({id:6,href:'/docs/angular/services/',title:"Services",section:"Angular",content:"Services (do STUFF) #  They are classes where you can put business logic for components. They should be specific. Components and services should be as reusable as possible. This is a good, short read about them: Services and DI.\nCreating them #  You usually create one in a .service.ts file. It is an exported class with functions which perform the required business actions. It can then be injected into the required classes. It might depend on other services too.\nRead more about dependency injection here.\n"}),a.add({id:7,href:'/docs/angular/routing/',title:"Routing",section:"Angular",content:"Routing \u0026amp; Co. #  Some modern apps, like the one built with Angular are Single Page Apps. They only load one HTML file from the server (index.html mostly) and then use JS to fetch new content and change parts of the page as the user navigates the site. It behaves like a regular sites in all aspects (look at the address bar) while being more efficient!\nCreating routes #  Routes are defined as an array of objects. The array is of the type Routes from \u0026ldquo;@angular/router\u0026rdquo;.\n The object should be like: {path:'', component: ComponentKlass} which is of type Route. You then pass the array as an argument to RouterModule.forRoot(routes) in an NgModule of your app (e.g. AppModule in app.module.ts) If you want a route to redirect, you can set it like so: {path:'blue', redirectTo: '/red', pathMatch: 'full'}  A good practice is to create a separate module for routing and then import the module in AppModule. This way, routes and the RouterModule import will be in a separate file e.g. app-routing.module.ts. The main AppModule may also choose to export the new router module you created so it will be available throughout the app.\nRoute parameters #  You can pass parameters in a route path, like so: path: 'warehouse/:id' where \u0026ldquo;id\u0026rdquo; is the parameter. To access it within your component code you should:\n Add ActivatedRoute as a dependency to your component Access the parameter via the dependency object, like so: route.snapshot.params[\u0026quot;id\u0026quot;] It is also recommended to setup a callback function with each param so that when navigating from that component to itself, the content is updated properly. This can be done like so:  route.params.forEach((param: Param) =\u0026gt; { // logic for updating content }) Links to routes #  You want Angular to generate the links to routes, not hardcode them. This is how you do it:\n Add the routerLink property to an element. As its value provide an array of path elements, like this: ['where', someParam], which will be joined with \u0026lsquo;/\u0026rsquo; and used. That element will be clickable and will go to that route when clicked. \u0026lt;a\u0026gt; elements will get an href property with the destination route as the value.  Navigate with JS #  You can also navigate the site, not just by clicking links, but also with JS if required. You just put Router from \u0026ldquo;@angular/router\u0026rdquo; as a dependency and then call routerName.navigate([/* path as an array of strings */])\nThere\u0026rsquo;s also an Angular service called Location from \u0026ldquo;@angular/core\u0026rdquo; with which you can go back to the previous page. To use it, inject it as a dependency and then do locationObj.back().\nGuards #  When you don\u0026rsquo;t want a user to visit or leave ceratin routes.\nActivation #  Used to prevent users from visiting a route unless some condition is satisfied. You can specify the condition via a function or service. You can do it with a service, like so:\n Define a service which has a canActivate method that takes in an ActivatedRouteSnap object as a param. This function returns true / false telling if the should be able to accessed. If you want you can do things like navigate to a 404 page from that function. Pass in the service in an array as the value to the canActivate key of the Route object you wish to guard. Like so: {path: 'event/:id', component: EventDetailsComponent, canActivate: [NavigationService]}  Deactivation #  Used to prevent users from leaving a page (they can always leave by changing the address in the address bar) unless some condition is satisfied. You can do it with a service, or with a function, like so:\n Define a function and add it as a provider. This means you need to create a Provider object and register it in the NgModule\u0026rsquo;s providers array. It needs the provide property which is a string that you can use to access this provider and useValue property whose value the function you just defined. An example: {provide: 'dontLoseData', useValue: checkBadDataState}. The function must return true / false which determines if the user can leave the page. You can then use this provider by accessing it via its key, like so: {path: 'event/new', component: abc, canDeactivate: ['dontLoseData']}  Active route #  You can add classes to elements which have [routerLink] when the current page is that link. That\u0026rsquo;s done with routerLinkActive='someKlass' property. To match exactly, you can set [routerLinkActiveOptions] to {exact: true}\nLazy loading a Module #  You can lazy load a module so that it only loads under a particular route. Therefore it saves bandwidth for the user when they just visit the main site. You define the module, its routes, and its components normally. Some changes:\n You import and use CommonModule instead of BrowserModule in NgModule. You use RouterModule.forChild instead of RouterModule.forRoot.  Then to load this particular module on a route you can define it in the main route, like so:\n{ // this is a Route object  path: \u0026#39;extraa\u0026#39;, loadChildren: () =\u0026gt; import(\u0026#39;extraStuff.module\u0026#39; /*the file where the module is defined*/).then( mod =\u0026gt; mod.FancyModule // the NgModule\u0026#39;d class  ) } To improve perceived performance, this module can be prefetched whenever the browser is free. This can be done by adding another argument to the root router module like so:\n@NgModule({ imports: [ // other modules  RouterModule.forRoot(mainRoutes, {preLoadingStrategy: PreLoadAllModules}) ] }) Prefetching with resolve #  When a user visits a route a resolver loads the data required for the page before the component is loaded. It helps fix issues caused when the component is ready but the data required for its content is not.\nA resolver is usually a service that has a resolve method that takes in an ActivatedRoute object and returns an Observable. The observable is automatically subscribed to.\nIn the list of routes, for a Route object, specify a resolve property that is equal to an object where the keys can be used to access the data on the route later on. Like so: resolve: { users: getUsersService }. This can then be accessed via the ActivatedRoute like so: this.route.snapshot.data['users']\n"}),a.add({id:8,href:'/docs/angular/forms/',title:"Forms",section:"Angular",content:"Forms and validation #  There are two kinds of forms in Angular:\n Template based (the content and the logic is in the HTML) Model based A.K.A. Reactive (the content and logic is in the component)  Creating a form #   You need the FormModule from \u0026ldquo;@angular/forms\u0026rdquo; to be imported in the module where you will be using forms. In the component with the form, on the form element, set a template reference variable like so: \u0026lt;form #someNiceNameForForm=\u0026quot;ngForm\u0026quot;\u0026gt;\u0026lt;/form\u0026gt;. This provides additional functionality as described in the docs. For each input element whose value you want, set the name attribute. This will be the key to access its value later on. For the submit action, prefer to bind to ngSubmit instead of using the submit button, like so: \u0026lt;form #formTempVar=\u0026quot;ngForm\u0026quot; (ngSubmit)=\u0026quot;handlerFunc(formTempVar.value)\u0026quot;\u0026gt;\u0026lt;/form\u0026gt; The value prop. on the temp-ref-var is an object where the value for each input field with a name attr. is available. You can also bind ngModel on each input element to bind it to values on the component, like so: \u0026lt;input (ngModel)=\u0026quot;compoProp\u0026quot; id=\u0026quot;foo\u0026quot; type=\u0026quot;text\u0026quot;\u0026gt;. To achieve two way data binding you can do this: [(ngModel)]=\u0026quot;compoProp.  Validation #  Angular turns off the default behaviour of adding the \u0026ldquo;required\u0026rdquo; attribute on input elements. It does provide its own validation features:\n formTempRefVar has properties like valid, invalid, touched, dirty etc. So does each input element, under formTempRefVar.controls.inputElementName. The element\u0026rsquo;s property under formTempRefVar.controls may not be defined initially, therefore, if you want to check if the element is in an invalid state you should do it like this: formTempRefVar.controls.inputElementName?.invalid    Reactive forms #  Here, the structure of the form and its validation rules are defined in the component itself. It\u0026rsquo;s more flexible and lets you unit test things like validation easily. Here\u0026rsquo;s how you make such a form:\n You need the ReactiveFormModule like how template forms need FormModule The form is a property of the component. It is of the type FormGroup. You initialize it in ngOnInit, like so:  let username = new FormControl(); let password = new FormControl(); let day = new FormControl(); let month = new FormControl(); let year = new FormControl(); let birthday = new FormGroup({ day: day, month: month, year: year }); this.userLoginForm = new FormGroup({ uname: username, paswd: password, dob: birthday })  The properties of the FormGroup are supposed to be the values you want from the form, or a group of values which are encased in a FormGroups of their own. You must bind the HTML form and input elements like so: \u0026lt;form [formGroup]=\u0026quot;userLoginForm\u0026quot;\u0026gt;\u0026lt;/form\u0026gt; and \u0026lt;input formControlName=\u0026quot;username\u0026quot;\u0026gt;\u0026lt;/input\u0026gt;. In case of grouped values, the group must be bound \u0026lt;div formGroupName=\u0026quot;dob\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; and then the constituent elements like so: \u0026lt;input formControlName=\u0026quot;month\u0026quot;\u0026gt;\u0026lt;/input\u0026gt; You can also add a ngModelGroup attribute so that the form value will be structured so that the input elements within the group will be nested inside an object. A structure like this \u0026lt;div ngModelGroup=\u0026quot;lol\u0026quot;\u0026gt;\u0026lt;input name=\u0026quot;hi\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; will give a value object like this:  { // other fields  lol: { hi: \u0026#34;someval\u0026#34; } } Validation (reactive form) #   The format for a new FormControl is: new FormControl(value the field should have, validation for the field) where both params are optional An example validation, where you can mark a field as required is: FormControl(userName, Validators.required) where Validators must be imported from \u0026ldquo;@angular/forms\u0026rdquo; The state of the form is accessible from the primary FormGroup like so: this.userLoginForm.valid To use multiple validators, pass them as an array: [Validators.required, Validators.pattern('ab*')] The results of each validator (pass / fail) can be obtained like userLoginForm.controls.elementName.errors.whatEverValidation where the validation is something like required or pattern or something else.  Custom validator #  A validator is a function. It returns an error object if the validation failed else it returns null. The error object looks like this: {'errorName': errorValue}. The error value can then be accessed like elementName.errors.errorName. The only argument that the function takes is a FormControl object (which will be the element on which the validator is set).\nSuper custom validator #  You can also use a directive as a validator. Since it is a class it needs to implement Validator from \u0026lsquo;@angular/forms\u0026rsquo; which means it needs to have a function validate that takes in a FormGroup (or FormControl depending on where the directive is used) and return null if there are no errors else an error object like before.\nSince it is a directive it needs to be imported in the ngModule. To add it to Angular\u0026rsquo;s list of validators (and therefore make it available for use) you can do this:\nimport { NG_VALIDATORS } from \u0026#39;@angular/forms\u0026#39; @Directive({ selector: \u0026#39;wow-nice\u0026#39; providers: [{ provides: NG_VALIDATORS, useExisting: NiceValidator, multi: true // this means add this validator as a provider to NG_VALIDATORS  }] }) export class NiceValidator { validate(fg: FormGroup) { /* validation logic */} } Multi-field validation #  You need to do a few weird things to validate multiple fields:\n To access sibling fields, use the root group like so fg.root.controls.siblingElement To actually validate elements with the directive validator you need a temp-ref-var like so: \u0026lt;div ngModelGroup=\u0026quot;niceGrp\u0026quot; validatorDirec #whyNeedIDK=\u0026quot;ngModelGroup\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; The sibling needs to re-run the validator whenever it updates. Can do that with an event binding: \u0026lt;div (change)=\u0026quot;whyNeedIDK.control.controls.someField.upDateValueAndValidity()\u0026gt;\u0026lt;/div\u0026gt;  This whole thing is just super complex and weird.\n"}),a.add({id:9,href:'/docs/angular/pipes/',title:"Pipes",section:"Angular",content:"Transforming data #  Built-in pipes #  You can transform data before it is rendered in a template. There are many inbuilt pipes. The format is {{ yourContent | pipeName:pipeArg1 }} where the arguments are JS objects / literals and are optional. Example: \u0026lt;p\u0026gt;A: {{a | currency:'CAD':'code'}}\u0026lt;/p\u0026gt;.\nCustom pipe #  An example pipe:\n// in the file goodie.pipe.ts import {Pipe, PipeTransform} from \u0026#39;@angular/core\u0026#39; @Pipe({ name: \u0026#39;goodiepipe\u0026#39; // the name used to call the pipe in the template }) export class GoodiePipe implements PipeTransform { // this is the function that is called with the args  transform(input: string, arg1: number) { if(arg1 \u0026lt; 5) return input+\u0026#34; is low\u0026#34;; return input+\u0026#34; is high\u0026#34;; } } You must then add it to the declarations of the NgModule where you want to use it. It can then be used like so: {{ someVar | goodpipe:32 }}\nFilter and Sort #  AngularJS had the ability to do this with pipes. This meant that every time the data changed (i.e. a change detection cycle), the pipe would have to be called. This was slow.\nAngular doesn\u0026rsquo;t recommend that you sort or filter with pipes (you usually can\u0026rsquo;t but there\u0026rsquo;s the option to do it with impure pipes). It is recommended to sort / filter in the component itself.\nAngular only runs a pipe when the identity of the data has changed. It\u0026rsquo;s value. It does not check if the reference has changed. Therefore, if you change the properties of an object, Angular will not run the pipe for it.\n Async #  You can subscribe and process values from RxJS observables within the template itself. This is possible via the async pipe. It\u0026rsquo;s often used with ngFor like this: \u0026lt;div *ngFor=\u0026quot;let book of books | async\u0026quot;\u0026gt;We have {{ book.name }}\u0026lt;/div\u0026gt; where books is an observable which has multiple next calls and a complete call.\n"}),a.add({id:10,href:'/docs/angular/di/',title:"Dependency Injection",section:"Angular",content:"Adding features! üôå #  Dependency injection #  This is how you provide new components with extra resources they need to function. To indicate that a class (any class, not just a component / service) has a dependency or is a dependency you decorate it with @Injectable(). From the docs\n The injector is the main mechanism. Angular creates an application-wide injector for you during the bootstrap process, and additional injectors as needed. You don\u0026rsquo;t have to create injectors.\nAn injector creates dependencies, and maintains a container of dependency instances that it reuses if possible.\n Some important points:\n You declare dependencies of a class in its constructor For each dependency, you must have registered a provider with the injector. A provider creates the dependency object when required. (For a service, it can be the service class itself)  Again, from the docs listed at the top of the page:\n When Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn\u0026rsquo;t yet exist, the injector makes one using the registered provider, and adds it to the injector before returning the service to Angular.\nWhen all requested services have been resolved and returned, Angular can call the component\u0026rsquo;s constructor with those services as arguments.\n Register a provider #  You can do it in three ways: In @Injectable() You can specify the provider as the value to the provider key in the metadata object. If you specify 'root' one instance will be available to all components.  With an NgModule You specify the provider (e.g. the service class) in the providers array and one instance will be available to all components in the module.  With a component You can place it in the providers array in the metadata of a component and it will get its own instance of that service.   To use a function as a provider check out this example.\nUsing InjectToken #  This is a way for the injector to find the required provider from the list of available providers. Its an alternative to using a string. Its better since the token is a variable and the compiler will complain if there is another variable with the same name.\nCreate a new token like this:\nimport { InjectionToken } from \u0026#39;@angular/core\u0026#39; let SOME_TOKEN = new InjectionToken\u0026lt;retType\u0026gt;(\u0026#39;whatever description you want\u0026#39;); // Its a convention to capitalize the token name // retType is the type of the object that this provider will create // \u0026#34;any\u0026#34; is a good option in case of a third-party object like jQuery Use it to register a new provider. The provide property will be set to SOME_TOKEN. The other prop. e.g. useValue contains the object that you want to provide e.g. jQuery\u0026rsquo;s $.\nThe object can now be used via DI like so:\nimport { Inject } from \u0026#39;@angular/core\u0026#39; import { SOME_TOKEN } from \u0026#39;./something.service\u0026#39; constructor(@Inject(SOME_TOKEN) private jqSelector) {} ngOnInit() { this.jqSelector.doSomething() } useWhat #  Alternatives to useValue\n The usual way where you put the service class within the providers array of the ngModule is a shorthand for {provider: someGoodClass, useClass: someGoodClass} useExisting lets you use a different, already registered (i.e. existing), provider when the user requests one provider. Something like this: {provider: someGoodClass, useExisting: someShadyClass} useFactory lets you use a function to create an object. This is complex. Check out the docs.  "}),a.add({id:11,href:'/docs/angular/rxjs/',title:"RxJS",section:"Angular",content:"Async \u0026amp; network stuff #  Not everything happens right at once in a webapp. It shouldn\u0026rsquo;t wait for certain events when it can execute other things. This is where asynchronous processing is useful. Promises were the preferred way to do it but now there are observables (from rxjs). Promises represent one event that happens in the future while observables represent zero or more events that could happen synchronously or in the future. This particular section is about RxJS and HTTP in Angular.\nGood resources for RxJS:\n  A gist that explains reactive programming  A single page crash course giving an overview of RxJS  Overview of main concepts. Official docs  Video showing off some RxJS stuff live  Video about RxJS stuff specific to Angular  HTTP #  To communicate via HTTP in JS first import HttpClientModule from \u0026ldquo;@angular/common/http\u0026rdquo; into the ngModule of your choice. Wherever required, a dependency of type HttpClient from \u0026ldquo;@angular/common/http\u0026rdquo; can be injected so that HTTP calls can be made with it.\nOnce you have an object of HttpClient, say http, you can perform calls such as: http.get\u0026lt;T\u0026gt;(url) where T is the type of the response you expect. The result is an Observable\u0026lt;T\u0026gt; which can be subscribed to.\nTo add query parameters just do string concatenation :). E.g. http.get\u0026lt;T\u0026gt;(url+\u0026quot;?userid=\u0026quot;+searchUserId) üå¥\nThere\u0026rsquo;s also the delete method and post method. The post method needs a few more args like so: http.post\u0026lt;T\u0026gt;(url, body, options). Where body is an object containing the data you want to give and options is also an object which has properties like HTTP headers.\nThe observables that the HTTP methods return just pass one value and then complete.\nRxJS üíß #  Helps in managing events in a functional programming and asynchronous manner. Its main concepts are:\nObservables #  An observable is a stream of lazy push-based computations. They can deliver values (zero to infinite) synchronously or asynchronously. Create one like this:\nimport { Observable } from \u0026#39;rxjs\u0026#39;; const obsv = new Observable(subscriber =\u0026gt; { // a stream of nexts optionally followed by either an error or a complete  // e.g. :  subscriber.next(anyValue1); subscriber.next(anyValue2); subscriber.next(anyValue3); subscriber.next(anyValue4); // only one of the following two should be there  subscriber.error(anyError); subscriber.complete(); }); The observable can then be subscribed to like so:\nconst subc = obsv.subscribe(value =\u0026gt; { console.log(value); }) The observable can also be stopped like so:\nsubc.unsubscribe(); // the behaviour of the function can be customized // by setting the return value of the subscription function const custom = new Observable(subscriber =\u0026gt; { // do some computation  return function unsubscribe() { // do clean up perhaps?  } }); Observables can be used in HTML templates. As a convention append a \u0026ldquo;$\u0026rdquo; while naming an observable so that it is distinguishable in the template.\nThere can be multiple subscribers. Each one will get the same stream of data. An observable may complete before some async operations within it have run. All subscribers will receive same series of next, error and complete events as each other. When one of them unsubscribes, it stops the flow of data to only that one.  Observer #  A consumer of an observable. Its just an object like this:\nconst observer = { next: value =\u0026gt; console.log(\u0026#39;Got a value: \u0026#39; + value), error: err =\u0026gt; console.log(\u0026#39;Finished with an error: \u0026#39; + err), complete: () =\u0026gt; console.log(\u0026#39;Finished peacefully\u0026#39;); }; const subc = obsv.subscribe(observer); Some or all properties can be ignored\nSubscriptions #  They are the objects returned on subscribing to an observable. They essentially have only 3 methods:\n unsubscribe(): stop receiving data from the observable add(otherSubscription): so that unsubscribing this subscription will unsubscribe the other one too remove(otherSubscription): to undo the add method described above  Operators #   Easy to use resource to figure out what kind of operator you need.\nThey transform the data produced by observables. They are functions. There are two kinds: Creation They generate observables from some kind of data / instruction. These functions return observables. An example is of from \u0026lsquo;rxjs\u0026rsquo;. It takes in one or more arguments and then creates an observable that pushes these objects one after the other.  Pipeable They generate observables from other observables. These functions return functions that take in an observable and return an observable. An example is map from \u0026lsquo;rxjs/operators\u0026rsquo;. You use it like let funk = map(x =\u0026gt; x+x) and then outputObsv = funk(inputObsv).   The official docs has a useful list of commonly used observables, grouped by category.\nMany times multiple pipeable operators are used in sequence. It becomes messy, thus we have the pipe function which can be used like this:\nconst obsv = of(1, 2, 3); const obsv1 = map(x =\u0026gt; x * x)(obsv); const obsv2 = filter(y =\u0026gt; y \u0026gt; 3)(obsv1); obsv2.subscribe(v =\u0026gt; console.log(v)); // is equivalent to  const subscrip = of(1, 2, 3).pipe( map(x =\u0026gt; x * x), filter(y =\u0026gt; y \u0026gt; 3) ).subscribe( v =\u0026gt; console.log(v) ); Subjects #  An observerable that can also be used as an observer. They can be used to make an observable multicast (They are unicast by default). Using it as an observable:\nimport { Subject } from \u0026#39;rxjs\u0026#39;; const obsv = new Subject\u0026lt;any\u0026gt;(); // the default type is void obsv.subscribe(/* an observer */); obsv.next(someVal1); obsv.next(someVal2); obsv.complete(); It can also be used as an observer. Just pass the Subject object to an observer\u0026rsquo;s subscribe method. This works since the Subject already has next, error, and complete methods.\nThe important difference between a subject and a normal observable is that a subject does not maintain separate execution contexts. A normal observer creates an independent execution context for each observer it has. Whenever an observer subscribes to a subject it can receive values from there on only. Not the old values. There are specialized subscribers that can buffer some old values to give new observers.  A cool trick is to make an observable multicast with a subject. Like so:\nimport { of, Subject } from \u0026#39;rxjs\u0026#39; const obsv = of([1, 2, 3, 4, 5]); const sub = new Subject\u0026lt;number\u0026gt;(); const scp1 = sub.subscribe(e =\u0026gt; console.log(e)); const scp2 = sub.subscribe(e =\u0026gt; console.log(e)); obsv.subscribe(sub); Some useful specialized subjects:\nBehaviourSubject #  Holds the current value that was pushed. When new observers subscribe, they immediately get that value. Afterwards they continue to get pushed values like other old observers.\nReplaySubject #  A generalized form of BehaviourSubject. It can hold a buffer of n previously pushed values and pass them at once to new observers. They are used like this: const sub = new ReplaySubject\u0026lt;number\u0026gt;(bufferSize, expirationTimeForEachValue [optional])\nVoid Subject #  This is the default type of subject created when no type is specified. The subscriber for this doesn\u0026rsquo;t receive any values for its next function. It\u0026rsquo;s useful when you just want to know that some event occured.\nScheduler #  Controls when subscriptions start. Can modify this so that subscriptions start immediately, on the next event loop, next micro loop, or after some timeout. This is kinda complex so here\u0026rsquo;s a link to the docs.\n"}),a.add({id:12,href:'/docs/angular/test/',title:"Testing",section:"Angular",content:"Unit \u0026amp; Integrated tests #  Angular uses Jasmine for unit testing and Karma to run the tests on browsers. Tests can be:\nIsolated  Only tests the JS class not the component Mostly used for services and pipes Need to create instances of classes on your own   Integrated  Tests the class and template together Mostly used for components and directives The objects are created by the framework    Unit tests #  They test a single unit (like a class, function, or a bunch of classes) in isolation. Some features of unit tests:\n Fast (to code and to execute) Should handle one state change at max Assert one thing Minimal dependencies  They follow a structure of:\n Assemble - The setup code for the test Action - The thing that the user will likely do. Can be a state change Assert - \u0026ldquo;Is the result what is expected?\u0026rdquo;  Run unit tests with ng test which asks Karma to look for *.spec.ts files and execute the tests within them. A basic test looks like this:\ndescribe(\u0026#39;a nice test\u0026#39;, () =\u0026gt; { // do something  beforeEach(() =\u0026gt; { // code to run before each \u0026#39;it\u0026#39;  }) it(\u0026#39;exact test stuff\u0026#39;, () =\u0026gt; { // do something  expected(valA).toBe(\u0026#39;good stuff\u0026#39;); }) }) toBe is just one of the many \u0026ldquo;matchers\u0026rdquo; jasmine has. The official docs has a list of matchers  Mocking #  To minimize depedencies on external code they are mocked for things like network calls, DB use, side effects etc. E.g. instead of making HTTP requests with the http dependency use a mock http dependency that simulates network calls and returns results immediately.\n Mock with jasmine like this: const mockStuff jasmine.createSpyObj('some desc', ['method1', 'method2', 'method3']). A particular method can be modified to return a particular value like this: mockStuff.method1.and.returnValue(anyValue) To check if a method is being called in the function with particular params, use: expect(mockStuff.method2).toHaveBeenCalledWith(param1, param2) where the parameters can be exact values or it can just check that the types match by passing in an arg like jasmine.any(ClassName) Components can be tested just like services for isolated tests. Instantiate the class with mock dependencies, set any input params and then test whatever methods needed to be tested.  Integrated tests #  They\u0026rsquo;re more complex and are meant to test an entire functionality. It can test the template and the component in an environment that\u0026rsquo;s a close approximation to real world usage.\nSetup #  This is more complex since Angular creates the instances of the component and template and places them in a module. This setup goes in a beforeEach. The code for this is usually generated by the cli when using ng g c and is placed in \u0026ldquo;*.component.spec.ts\u0026rdquo;. It looks like this:\n// inside a describe callback let component: NiceComponent; // the type let fixture: ComponentFixture\u0026lt;NiceComponent\u0026gt;; // from \u0026#34;@angular/core/testing\u0026#34; let debugEl: DebugElement; // handle to the template let rawHTML: HTMLElement; // handle to the raw html of the template  let mockThatService; // mock object for a dependency  beforeEach(() =\u0026gt; { // if you don\u0026#39;t want complex functionality no need to use a spyObj  // a simple object with the props required will do  mockThatService = {}; // creates the module where the component will run  TestBed.configureTestingModule({ declarations: [ component ], providers: [ { provide: ThatService, useValue: mockThatService } ] }); fixture = TestBed.createComponent(NiceComponent); component = TestBed.componentInstance; debugEl = TestBed.debugElement; rawHTML = TestBed.nativeElement; // runs change detection so the template is kept updated with the component  fixture.detectChanges(); }) Deep \u0026amp; Shallow tests #  A shallow integration test just includes the component that is being tested while a deep test will also include the necessary children component (but may not test them). A deep test is heavy because of dependencies but it is complete.\nWhen using a shallow test, it is possible to ignore the errors caused by dependencies on other components. This is done by adding a schema to the testing module like so:\nTestBed.configureTestingModule({ declarations: [/* wtv */], providers: [/* wtv */], schemas: [ NO_ERRORS_SCHEMA // from angular core  ] }) "}),a.add({id:13,href:'/posts/rtfm/',title:"RTFM",section:"Blog",content:"What is this? Why is this? #  As much as I like Stackoverflow and Google and the work they\u0026rsquo;ve done, it\u0026rsquo;s still hard to find exactly the right information exactly when you want it.\nI think that is because we are all at different stages in software development and have varied knowledge about things. You might know more about CSS Grids than someone else and they might know more about JavaScript requests. You probably even understand things differently and have different mental models. That\u0026rsquo;s why I\u0026rsquo;m writing this. (Also because writing things down helps you remember stuff.)\nThese are notes, basically #  Yeah, that\u0026rsquo;s about it. Notes by me, taken from random sources, for me. You are free to use them and even suggest edits (through GitHub) if you like.\nOh also, this theme is crazy good and has a lot of features. It\u0026rsquo;s gonna take me a while to make use of all of them and reach a good level of productivity.\nHave fun! üôÇ\n"}),a.add({id:14,href:'/credits/',title:"Credits",section:"Introduction",content:"Credits #   Built with HUGO Uses the hugo-book theme  Compass icon by Icons8  You can find the source for this site on GitHub.\n"})})()